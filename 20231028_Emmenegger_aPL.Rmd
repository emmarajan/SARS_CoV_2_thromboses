---
title: "Antiphospholipids, SARS-CoV-2 antibodies, cytokines, and thromboses"
author: 
  - Vishalini Emmenegger^[BEL, D-BSSE, ETH Zurich]
  - Marc Emmenegger^[University Hospital Zurich and University Hospital Basel, marc.emmenegger@usb.ch]
date: "2023-10-28"
output: 
  html_document:
    number_sections: TRUE
    keep_md: yes
    css: style.css
    code_folding: "hide"
documentclass: article
fontsize: 11pt
linkcolor: blue
mainfont: Arial
toc: true
toc_float: true
toc_depth: 6
mathjax: null
css: doc.css
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(dev= c('png', 'pdf'), fig.align = 'center', fig.height = 10, fig.width = 10, pdf.options(encoding = "ISOLatin9.enc"), echo=TRUE, fig.path = 'figures/') 
```

# PREPARATIONS {.tabset .tabset-fade .tabset-pills}

## LOAD ESSENTIAL LIBRARIES 

```{r LOAD ESSENTIAL LIBRARIES, message=FALSE}
library(openxlsx)
library(tidyverse)
library(tidyr)
library(dplyr)
library(purrr)
library(magrittr)
library(broom)
library(stringi)
library(RColorBrewer)
library(table1)
library(gplots)
library(ggplot2)
library(ggdendro)
library(dendextend)
library(ggridges)
library(cowplot) 
library(ggpubr)
library(factoextra)
library(FactoMineR)
require(graphics)
library(corrplot)
library(PupillometryR)
library(fmsb)
library(ggsci)
library(psych)
library(viridis)
library(mgcv)
library(Hmisc)
library(MASS)
library(tis)
library(Boruta)
library(ROCR)
library(earth)
library(Lahman)
library(rstanarm)
#options(mc.cores = parallel::detectCores())

```

## SETUP AND FUNCTIONS

```{r SETUP AND DEFINE FUNCTIONS}
col <- brewer.pal(n=11, name="RdBu")
render.cont <- function(x) { with(stats.default(x), c("", "Mean (SD)" = sprintf("%0.1f (%0.1f)", MEAN, SD), "Median (IQR)" = sprintf("%0.1f (%0.1f to %0.1f)", MEDIAN, Q1, Q3), "Range" = sprintf("%0.0f to %0.0f", MIN, MAX))) }
render.cat <- function(x) { c("", sapply(stats.default(x), function(y) with(y, sprintf("%d (%0.1f%%)", FREQ, PCTnoNA)))) }

cor.mtest <- function(mat, ...) {
  mat <- as.matrix(mat)
  n <- ncol(mat)
  p.mat<- matrix(NA, n, n)
  diag(p.mat) <- 0
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n) {
      tmp <- cor.test(mat[, i], mat[, j], ...)
      p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
    }
  }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}

logit = function(x) log(x/(1-x))
inv.logit = function(x) exp(x)/(1+exp(x))
qsum = function(x) c(quantile(x,probs=c(0.5,0.025,0.975)))

# Throughout the manuscript, the significance level alpha chosen is 0.01
signifiance_stars <- list(cutpoints = c(0, 0.00001, 0.0001, 0.001, 0.01, Inf), symbols = c("****", "***", "**", "*", "ns"))


col1 <- c("#0073C299", "#EFC00099", "#86868699", "#CD534C99", # normal JCO
         "#7AA6DC99", "#003C6799", "#8F770099", "#3B3B3B99")
         
col2 <- c("#EFC00099", "#86868699") # when comparing infected versus non-infected

col3 <- c("#0073C299", "#86868699", "#CD534C99", # when non-infected/non-vaccinated are dropped
         "#7AA6DC99", "#003C6799", "#8F770099", "#3B3B3B99")
         
col4 <- c("#4169e1", "#FF00E0", "#FFC501") # for antibody isotypes

col5 <- c("#0073C299", "#86868699", "#7AA6DC99") # when comparing those with acute infection (influenza, inf/non-vac, inf/vac)
```

## LOAD, PREPROCESS, AND PROCESS DATA

### We read the data

```{r READ DATA}
data <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'Tabelle1')
aPL <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'All_aPL')
CoV2 <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'All_TRABI')
data_vertical <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'Sheet1')
data_vertical_tp <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'Sheet2')
published_data <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'published_data')
published_data_comparison <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'published_comparison')
Cytokines <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'Sheet3')
Cytokines_classifications <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'Cyto_groups')
Cytokines_ref <- read.xlsx('..\\Dataset\\Prothrombin_follow_up_v02.xlsx', na.strings = c("NA", ""), sheet = 'Cytokines_ref')
```

### We add the aPL and the CoV2 datasets

```{r MERGE DATA}
data = merge(x = data, y = aPL, by = "Unique_sample_ID_for_study", all = TRUE)
data = merge(x = data, y = CoV2, by = "Unique_sample_ID_for_study", all = TRUE)
```

### We clean up a bit by retaining only essential information for the subsequent steps

```{r PERFORM CLEANUP}
data <- data %>% 
  dplyr::select(Unique_sample_ID_for_study, Patient_study_ID, Unique_patient_ID,
         Sex, Age, Sample_type, Cohort_type, Timepoint, Vaccination_statusonly_CoV2,
         Thrombosis_group, 
         `COVID_vaccination_Group`, 
         `DPOCoV2_or_FLU`, `SeverityCoV2_or_Flu`, Acute_SARS_CoV_2_infection, Anticoagulation.at.event:Immunosuppressed_admission, 
         CL_IgG:PT_IgA, Spike_IgG:NC_IgA
         )

published_data_comparison = published_data_comparison %>%
  dplyr::mutate(aPL_signal=as.numeric(aPL_signal))
```

### We generate an extra dataframe that can be used for cohort characterisation/demography

```{r FOR DEMOGRAPHY}
data_demo <- data %>% # Here, we want to have only the first timepoint for all samples. N=31 have two samples.
  dplyr::filter(!(Timepoint==2)
  )
```

### We preprocess the dataset containing already published data (a comparison dataset)

```{r PUBLISHED DATA}
published_data_comparison_NA <- published_data_comparison %>%
  filter(!is.na(as.numeric(aPL_signal)))

published_data_comparison_NA$aPL_signal <- as.numeric(published_data_comparison_NA$aPL_signal)
```

### We conduct a PCA on the CoV-2 IgG and IgA data

We have done so in our previous study (<https://doi.org/10.1371/journal.ppat.1010118>) as a compound metric to combine the measurements against the spike, the RBD, and the NC protein. As, here, we have IgG and IgA measurements, we have to do it for both of them, separately. We will thus end up with two compound scores, instead of six individual measurements, which can facilitate correlating data subsequently.

```{r PREPROCESSING PCA SARS-CoV-2 data, fig.height = 10, fig.width = 10}
mat_data_select_IgG <- data.matrix(data[51:53])
rownames(mat_data_select_IgG) <- data[,1]                  

mat_data_select_IgA <- data.matrix(data[54:56])
rownames(mat_data_select_IgA) <- data[,1]                  

set.seed(42)
mat_data_select_IgG.pca <- prcomp(na.omit(mat_data_select_IgG), center = TRUE, scale = FALSE)

set.seed(42)
mat_data_select_IgA.pca <- prcomp(na.omit(mat_data_select_IgA), center = TRUE, scale = FALSE)

PCA_IgG_plasma <- as.data.frame(mat_data_select_IgG.pca$x)
PCA_IgA_plasma <- as.data.frame(mat_data_select_IgA.pca$x)

PCA_IgG_plasma <- tibble::rownames_to_column(PCA_IgG_plasma, 'Unique_sample_ID_for_study')
PCA_IgA_plasma <- tibble::rownames_to_column(PCA_IgA_plasma, 'Unique_sample_ID_for_study')

data <- data  %>%
  dplyr::left_join(dplyr::select(PCA_IgG_plasma, Unique_sample_ID_for_study, PC1), by = "Unique_sample_ID_for_study") %>%
  dplyr::rename('PC1_IgG'='PC1') %>%
  dplyr::left_join(dplyr::select(PCA_IgA_plasma, Unique_sample_ID_for_study, PC1), by = "Unique_sample_ID_for_study") %>%
  dplyr::rename('PC1_IgA'='PC1')

data$PC1_IgA <- data$PC1_IgA*(-1) #change directionality to align with IgG

data_PCA <- data %>%
  dplyr::select(Unique_sample_ID_for_study, PC1_IgG, PC1_IgA) #Update this dataset, too
data_vertical <- left_join(data_vertical, data_PCA, by = "Unique_sample_ID_for_study")

pairs.panels(data[c(51:58)], alpha=0.01, stars=TRUE, ci=TRUE, method = 'spearman', cor=TRUE, lm=TRUE, smooth = TRUE, scale = FALSE, ellipses = FALSE)
```

### We calculate the mean value of IgG, IgM, and IgA aPL per sample (patient)

```{r aPL ROWSUM}
data$aPL_IgG_rowmean <- as.numeric(rowMeans(data[,21:30]))
data$aPL_IgM_rowmean <- as.numeric(rowMeans(data[,31:40]))
data$aPL_IgA_rowmean <- as.numeric(rowMeans(data[,41:50]))
```

### Lastly, we add the cytokines datasets

```{r MERGE CYTOKINES}
data = merge(x = data, y = Cytokines, by = "Unique_sample_ID_for_study", all = TRUE)

cytokines_z <- data %>%
    dplyr::mutate(as.data.frame(scale(data[,62:78]))) %>% # Z score of cytokine values
    dplyr::select(Unique_sample_ID_for_study:Acute_SARS_CoV_2_infection,
                  GCSF:Inflammatory_index, -DPOCoV2_or_FLU) %>%
    dplyr::mutate(Acute_SARS_CoV_2_infection = ifelse(COVID_vaccination_Group == '00_Influenza_Non-infected/non-vaccinated',  TRUE, Acute_SARS_CoV_2_infection)) %>% #Careful, this dataset is strictly used for some cytokine-related analyses. We have changed the acute infection entries here. While, everywhere else, this refers to acute infection with SARS-CoV-2, we change it here to an acute infection with SARS-CoV-2 OR with influenza
  dplyr::rename(Acute_infection=Acute_SARS_CoV_2_infection) %>% #the semantic change is followed by the nominal change
    na.omit()

cytokines_acute <- data %>%
    dplyr::select(Unique_sample_ID_for_study:Acute_SARS_CoV_2_infection,
                  GCSF:Inflammatory_index, -DPOCoV2_or_FLU) %>%
    dplyr::mutate(Acute_SARS_CoV_2_infection = ifelse(COVID_vaccination_Group == '00_Influenza_Non-infected/non-vaccinated',  TRUE, Acute_SARS_CoV_2_infection)) %>% #Careful, this dataset is strictly used for some cytokine-related analyses. We have changed the acute infection entries here. While, everywhere else, this refers to acute infection with SARS-CoV-2, we change it here to an acute infection with SARS-CoV-2 OR with influenza
  dplyr::rename(Acute_infection=Acute_SARS_CoV_2_infection) %>% #the semantic change is followed by the nominal change
    na.omit()

cytokines_vertical <- left_join(data_vertical, Cytokines, by = "Unique_sample_ID_for_study")

cytokines_vertical_z <- cytokines_vertical %>%
  dplyr::mutate(as.data.frame(scale(cytokines_vertical[,21:38]))) # Z score of cytokine values

cytokines_vertical = cytokines_vertical %>%
  dplyr::select(Unique_sample_ID_for_study:Inflammatory_index) %>%
  tidyr::pivot_longer(GCSF:Inflammatory_index,
               names_to = c('Cytokine_signal'),
               values_to = c('Cytokine_value'))

cytokines_vertical_z = cytokines_vertical_z %>%
  dplyr::select(Unique_sample_ID_for_study:Inflammatory_index) %>%
  tidyr::pivot_longer(GCSF:Inflammatory_index,
               names_to = c('Cytokine_signal'),
               values_to = c('Cytokine_value'))

cytokines_acute_longer <- cytokines_acute %>%
  dplyr::select(Unique_sample_ID_for_study:Inflammatory_index) %>%
  tidyr::pivot_longer(GCSF:Inflammatory_index,
               names_to = c('Cytokine_signal'),
               values_to = c('Cytokine_value'))

cytokines_acute_longer_z <- cytokines_acute %>%
  dplyr::mutate(as.data.frame(scale(cytokines_acute[,14:30]))) %>% # Z score of cytokine values
  dplyr::select(Unique_sample_ID_for_study:Inflammatory_index) %>%
  tidyr::pivot_longer(GCSF:Inflammatory_index,
               names_to = c('Cytokine_signal'),
               values_to = c('Cytokine_value'))

```

*We end up with our final dataset.* It is important to take note that for few (<5) patients with two timepoints but only one cytokine measurement, the cytokine measurement was reflected in both samples, i.e. duplicated. We aimed to avoid as many NAs as possible as these interfere with subsequent analyses and models.

## SOME INITIAL STATEMENTS

*The code chunks and approaches rendered here have been inspired by many people, known and unknown. Amongst them are David Lamparter, Raphaël P. B. Jacquat, Julien Riou, Dominik Menges, and Tala Ballouz, with whom we have developed code in the past (https://doi.org/10.5281/zenodo.7454292). Sreedhar Saseendran Kumar, Shalini's colleague at BEL and our dear friend, has been part of the predecessor of this study (published here: https://doi.org/10.1371/journal.ppat.1010118). Our beloved friend Sumana Srivatsa, formerly at ETH Zurich (Beerenwinkel group) and now residing in California, is always there for us with advice, help, and inspiration. We also thank enquirers and those knowledgeable enough to provide answers in the many online fora for sharing their investigations with all of us. This notebook is not to be considered a replacement of a manuscript. We develop code, ideas, and analyses along the way; we try to keep track and enable others to be part of our thought process. The order, arrangement, and interpretation of plots and analyses may (slightly) change when included in a scientific manuscript. If some interpretations do not entirely converge between the manuscript and the notebook, those in the manuscript are the ones that have been discussed, shaped, and validated. This notebook is not a publication but, for us, a convenient way to go back and refine, modify, mend or append some analyses, and we believe this is a good way for collaborators to independently validate our approach, and for readers and other scientists to understand what we have done and adapt material for their own needs. This manuscript is co-developed with a large kinetic study on immune responses in critically-ill patients, with cohorts from Zurich, Spain, and Andorra - and some of the approaches we conduct, and develop for our purpose, here, are directly used in the other study, too. If there are questions regarding the code, we are happy if you get in touch (marc.emmenegger@usb.ch).*

# INTRODUCTION AND MOST IMPORTANT QUESTIONS {.tabset .tabset-fade .tabset-pills}

## Background

Following an infection with SARS-CoV-2, potentially leading to COVID-19, endothelial damage and the antiviral immune response elicit a cascade of events. Among the most notable symptoms reside inflammation with potential cytokine storms, complement system activation, NETosis, platelet activation, and COVID-19-associated coagulopathy. These disturbances have shown to cause deep-vein thrombosis, pulmonary embolism, myocardial injury and infarction, and stroke (https://doi.org/10.1038/s41569-021-00665-7). Recent reports have likened many of these phenotypes associated with SARS-CoV-2-infection with the antiphospholipid syndrome.

We have recently described (<https://doi.org/10.1371/journal.ppat.1010118>) that some antiphospholipid antibodies are enriched in individuals concomitant to and after an infection with SARS-CoV-2 versus non-infected controls. Specifically, we have seen

1.  an enrichment for AnV, B2GPI, and PT IgM but not IgG;
2.  an association between PT IgM and the strength of the anti-SARS-CoV-2 antibody response;
3.  and, to a limited extent, an association with DPO, severity, and sex.

Among the many potential disturbances in coagulatory function, which of them are responsible for the increased occurrence of thromboses is still unclear. We therefore, molecularly, characterise a heterogeneous cohort of individuals following infection with SARS-CoV-2 and/or vaccination with mRNA vaccines, aiming to study potential connections between antibodies against SARS-CoV-2 proteins, cytokine levels, and an extensive panel of antiphospholipid antibodies (aPL). While we potentially reveal causal relationships that interfere with coagulation and that may lead to coagulation, another option may be that some of the signatures could serve as biomarkers. However, increased aPL levels may also be merely an epiphenomenon.

Some literature:

- https://doi.org/10.1016%2Fj.ajem.2020.09.072
- This is likely one of the important state-of-the-art manuscripts on which we base our study: https://doi.org/10.1038/s41569-021-00665-7 
- https://doi.org/10.1136/bmj-2021-069590

With respect to statistical models and approaches, we typically refer to the following texts:

- Gelman, Carlin, et al. Bayesian Data Analysis-Third Edition (2014)
- Lambert, A Student's Guide to Bayesian Statistics (2018)
- McElreath, Statistical Rethinking (2020)
- Zar, Biostatistical Analysis (2014)
- Szklo, Nieto, Epidemiology (2019)

## Aims and questions

In the current study, we aim to validate some of the previous results and aim to extend the work previously performed. The most important questions we aim to ask are:

1.  Can we reproduce the findings from our previous study?

2.  As a follow-up to our previous study, can we say anything about seroconversion of IgM to IgG or to IgA?

3.  If we compare the aPL levels in SARS-CoV-2 infected individuals to another disease, here influenza, does it look generic or specific to SARS-CoV-2?

4.  Is it infection with SARS-CoV-2 that elicits higher levels of aPL IgM, or equally so vaccination with mRNA vaccine?

5.  Are thrombotic events linked to the occurrence of aPL? Or to something else? We have not, previously, linked the finding to a clinical phenotype. Here, we may have the chance to identify such an association:

# COHORT CHARACTERISATION {.tabset .tabset-fade .tabset-pills}

Here, we characterise the cohort based on the most important demographic and clinical features. We have to be a bit careful doing so as we included more than one timepoint in few samples (n=31, in total n=155 samples). Characteristics indicated here, therefore, refer to the first timepoint only, in case multiple timepoints are available. The characterisation performed here is a general one. For specific questions posed further downstream, we may have to indicate some of these features again, to justify certain comparisons and to adjust for sex and age, e.g.

-   How many individuals? n=124
-   How many samples? n=155
-   How many samples when accounting for the loss of samples due to NA values in the cytokine dataset? n=112
-   For how many individuals more than one timepoint? n=31

## Cohort characterisation - table 1

```{r COHORT CHARACTERISATION, fig.height = 10, fig.width = 10}
table1(~ Age + Sex +
         as.numeric(DPOCoV2_or_FLU) +
         as.factor(Vaccination_statusonly_CoV2) + COVID_vaccination_Group +
         SeverityCoV2_or_Flu + Acute_SARS_CoV_2_infection + Anticoagulation.at.event + 
         Anticoagulation.chronic + Platelet.aggregation.inhibitor.at.event + 
         Platelet.aggregation.inhibitor.chronic + as.factor(Immunosuppressed_admission) + Thrombosis_group,
       render.continuous = render.cont, render.categorical = render.cat, 
       data = data_demo)
```

The table provides us with the most important measure to characterise the cohort. We can generate a second table where we, additionally, group according to infection with SARS-CoV-2/vaccination with mRNA vaccine.

## Cohort characterisation - table 2

```{r COHORT CHARACTERISATION GROUPED, fig.height = 10, fig.width = 10}
table1(~ Age + Sex +
         as.numeric(DPOCoV2_or_FLU) +
         as.factor(Vaccination_statusonly_CoV2) +
         SeverityCoV2_or_Flu + Acute_SARS_CoV_2_infection + Anticoagulation.at.event + 
         Anticoagulation.chronic + Platelet.aggregation.inhibitor.at.event + 
         Platelet.aggregation.inhibitor.chronic + as.factor(Immunosuppressed_admission) + Thrombosis_group
       | COVID_vaccination_Group,
       render.continuous = render.cont, render.categorical = render.cat, 
       data = data_demo)
```

For reference, we build the same table where we show the characteristics for all samples, and not just the individuals. This is not for the manuscript but contains information we need to look up frequently...

## Cohort characterisation - table 3

```{r COHORT CHARACTERISATION GROUPED FOR SAMPLES, fig.height = 10, fig.width = 10}
table1(~ Age + Sex +
         as.numeric(DPOCoV2_or_FLU) +
         as.factor(Vaccination_statusonly_CoV2) +
         SeverityCoV2_or_Flu + Acute_SARS_CoV_2_infection + Anticoagulation.at.event + 
         Anticoagulation.chronic + Platelet.aggregation.inhibitor.at.event + 
         Platelet.aggregation.inhibitor.chronic + as.factor(Immunosuppressed_admission) + Thrombosis_group
       | COVID_vaccination_Group,
       render.continuous = render.cont, render.categorical = render.cat, 
       data = data)
```

## Cohort characterisation - table 4

```{r COHORT CHARACTERISATION GROUPED FOR aPL indiv, fig.height = 10, fig.width = 10}
table1(~ CL_IgG + PA_IgG + PC_IgG + PE_IgG + PG_IgG + PI_IgG + PS_IgG + AnnV_IgG + ß2GPI_IgG + PT_IgG + CL_IgM + PA_IgM + PC_IgM + PE_IgM + PG_IgM + PI_IgM + PS_IgM + AnnV_IgM + ß2GPI_IgM + PT_IgM + CL_IgA + PA_IgA + PC_IgA + PE_IgA + PG_IgA + PI_IgA + PS_IgA + AnnV_IgA + ß2GPI_IgA + PT_IgA | COVID_vaccination_Group,
       render.continuous = render.cont, render.categorical = render.cat, 
       data = data)

```

## Cohort characterisation - table 5

```{r COHORT CHARACTERISATION GROUPED FOR anti-SARS-CoV-2 ab, fig.height = 10, fig.width = 10}
table1(~ Spike_IgG + RBD_IgG + NC_IgG + Spike_IgA + RBD_IgA + NC_IgA
       | COVID_vaccination_Group,
       render.continuous = render.cont, render.categorical = render.cat, 
       data = data)

```

## Cohort characterisation - table 6

```{r COHORT CHARACTERISATION GROUPED FOR cytokines, fig.height = 10, fig.width = 10}
table1(~ GCSF + GMCSF + IFNalpha + IFNgamma + IL1beta + IL4 + IL6 + IL8 + IL10 + IL17A + IP10 + MIP1alpha + MIP1beta + S100A8_A9 + SDF1alpha + TNFalpha + Inflammatory_index + Inflammatory_index_IFNgamma
       | COVID_vaccination_Group,
       render.continuous = render.cont, render.categorical = render.cat, 
       data = data)

```

## Cohort characterisation - table 7

```{r COHORT CHARACTERISATION GROUPED FOR aPL, fig.height = 10, fig.width = 10}
table1(~ aPL_signal
       | Isotype,
       render.continuous = render.cont, render.categorical = render.cat, 
       data = data_vertical_tp)

```

# DESCRIPTIVE OVERVIEW AND DATA EXPLORATION {.tabset .tabset-fade .tabset-pills}

## We look at the data with heatmaps, using informative groups

```{r DESCRIPTIVE OVERVIEW PART 1, fig.height = 10, fig.width = 10}
Data_heatmap <- data.frame(data[c(1, 11, 21:50, 51:56, 62:78)])
Data_heatmap <- Data_heatmap[order(Data_heatmap$COVID_vaccination_Group, Data_heatmap$Unique_sample_ID_for_study),]

Data_heatmap_aPL <- Data_heatmap %>% 
  dplyr::select(CL_IgG:PT_IgA)

Data_heatmap_aPL <- as.matrix(Data_heatmap_aPL)
rownames(Data_heatmap_aPL) <- Data_heatmap[,1]

Data_heatmap_CoV2 <- Data_heatmap %>% 
  dplyr::select(Spike_IgG:NC_IgA)

Data_heatmap_CoV2 <- as.matrix(Data_heatmap_CoV2)
rownames(Data_heatmap_CoV2) <- Data_heatmap[,1]

Data_heatmap_Cytokines <- Data_heatmap %>% 
  dplyr::select(GCSF:Inflammatory_index)

Data_heatmap_Cytokines <- as.matrix(Data_heatmap_Cytokines)
rownames(Data_heatmap_Cytokines) <- Data_heatmap[,1]

##### aPL

# Choose colours
my_paletteaPL <- colorRampPalette(brewer.pal(11, "Spectral"))(n = 99)

# scale for heatmap
colorsaPL = c(seq(0.0,100.0,length=100)) 

# Create the heatmap
heatmap.2(Data_heatmap_aPL,
          Rowv=FALSE,
          Colv="NA",
          margin=c(8,15),dendrogram=c("none"),
          RowSideColors=col1[as.factor(Data_heatmap$COVID_vaccination_Group)],
          col= my_paletteaPL,
          symm=F,symkey=F,symbreaks=T, scale="none",
          breaks=colorsaPL,
          sepwidth=c(0.01,0.01),
          sepcolor="white",
          colsep=1:ncol(Data_heatmap_aPL),
          labCol=NULL,
          cexRow=0.01, cexCol=0.75,
          na.color="grey",# Opposed to other molecular data, we have NA data here, so we mark them.
          key=TRUE,keysize=1.5,trace="none",density.info=c("none"))

##### CoV2

# Choose colours
my_paletteCoV2 <- colorRampPalette(brewer.pal(9, "Purples"))(n = 99)

# scale for heatmap
colorsCoV2 = c(seq(2.0,6.0,length=100)) 

# Create the heatmap


heatmap.2(Data_heatmap_CoV2,
          Rowv=FALSE,
          Colv="NA",
          margin=c(8,15),dendrogram=c("none"),
          RowSideColors=col1[as.factor(Data_heatmap$COVID_vaccination_Group)],
          col= my_paletteCoV2,
          symm=F,symkey=F,symbreaks=T, scale="none",
          breaks=colorsCoV2,
          sepwidth=c(0.01,0.01),
          sepcolor="white",
          colsep=1:ncol(Data_heatmap_CoV2),
          labCol=NULL,
          cexRow=0.01, cexCol=0.75,
          na.color="grey",# Opposed to other molecular data, we have NA data here, so we mark them.
          key=TRUE,keysize=1.5,trace="none",density.info=c("none"))

##### Cytokines

# Choose colours
my_paletteCytokines <- colorRampPalette(brewer.pal(9, "RdBu"))(n = 99)

# scale for heatmap
colorsCytokines = c(seq(-3,3,length=100)) 

# Create the heatmap

heatmap.2(Data_heatmap_Cytokines,
         Rowv=FALSE,
         Colv="NA",
         margin=c(8,15),dendrogram=c("none"),
         RowSideColors=col1[as.factor(Data_heatmap$COVID_vaccination_Group)],
         col= my_paletteCytokines,
         symm=F,symkey=F,symbreaks=T, scale="column", #As the different columns vary quite a bit, we scale the data here
         breaks=colorsCytokines, #Careful when setting the breaks when scale = 'column' is on...
         sepwidth=c(0.01,0.01),
         sepcolor="white",
         colsep=1:ncol(Data_heatmap_Cytokines),
         labCol=NULL,
         cexRow=0.01, cexCol=0.75,
         na.color="grey",# Opposed to other molecular data, we have NA data here, so we mark them.
         key=TRUE,keysize=1.5,trace="none",density.info=c("none"))
```

-   Blue: non-infected/non-vaccinated influenza patients
-   Yellow: non-infected/non-vaccinated control patients
-   Grey: infected/non-vaccinated
-   Scarlet: non-infected/vaccinated
-   Light blue: infected/vaccinated

## We look at the data with ridge plots using informative groups

```{r DESCRIPTIVE OVERVIEW PART 2, fig.height = 10, fig.width = 10, message=FALSE, warning=FALSE}
##### aPL

ggboxplot(
    data=subset(data_vertical, CoV2_type == 'Spike_IgG'), x = "aPL_type", y = "aPL_signal",
    color = "COVID_vaccination_Group", palette = "jco", outlier.shape = NA, add = 'mean'
    ) +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  guides(x =  guide_axis(angle = 90)) +
  theme_classic()


subset(data_vertical,CoV2_type == 'Spike_IgG') %>%
  dplyr::arrange(COVID_vaccination_Group) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("CL_IgG"), "A.CL_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PA_IgG"), "B.PA_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PC_IgG"), "C.PC_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PE_IgG"), "D.PE_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PG_IgG"), "E.PG_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PI_IgG"), "F.PI_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PS_IgG"), "G.PS_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("AnnV_IgG"), "H.AnV_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("ß2GF.PI_IgG"), "I.ß2GPI_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PT_IgG"), "J.PT_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("CL_IgM"), "K.CL_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PA_IgM"), "L.PA_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PC_IgM"), "M.PC_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PE_IgM"), "N.PE_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PG_IgM"), "O.PG_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PI_IgM"), "P.PI_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PS_IgM"), "Q.PS_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("AnnV_IgM"), "R.AnV_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("ß2GP.PI_IgM"), "S.ß2GPI_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PT_IgM"), "T.PT_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("CL_IgA"), "U.CL_IgA")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PA_IgA"), "V.PA_IgA")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PC_IgA"), "W.PC_IgA")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PE_IgA"), "X.PE_IgA")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PG_IgA"), "Y.PG_IgA")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PI_IgA"), "Z.PI_IgA")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PS_IgA"), "ZA.PS_IgA")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("AnnV_IgA"), "ZB.AnV_IgA")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("ß2GZ.PI_IgA"), "ZC.ß2GPI_IgA")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PT_IgA"), "ZD.PT_IgA")) %>%
  ggplot(aes(x = as.numeric(aPL_signal) , y = aPL_type, fill=COVID_vaccination_Group)) +
    geom_density_ridges(
      aes(point_color = COVID_vaccination_Group, point_fill = COVID_vaccination_Group, scale = 0.5),
      alpha = .8, point_alpha = 1, jittered_points = TRUE) + #bandwith could be manually adjusted
    ggtitle('All aPL grouped') +
    xlab('aPL signal') +
    ylab('aPL types') +
    scale_fill_manual(values=col1) +
    scale_point_color_hue(l = 40) +
    ggplot2:::manual_scale("point_color", values = col1, guide = "none") +
    theme_ridges(grid = FALSE, center = TRUE) +
    geom_vline(xintercept=50, linetype="dashed", 
               color = "red", linewidth=1)

##### CoV-2

ggboxplot(
  data=subset(data_vertical, aPL_type == 'CL_IgG'), x = 'CoV2_type', y = "CoV2_signal",
  color = "COVID_vaccination_Group", palette = "jco", outlier.shape = NA
) +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
  geom_hline(yintercept=2, linetype="dashed", color = "red", size=1) +
  guides(x =  guide_axis(angle = 90)) +
  theme_classic()

subset(data_vertical, aPL_type == 'CL_IgG') %>%
  dplyr::arrange(COVID_vaccination_Group) %>%
  dplyr::mutate(CoV2_type = str_replace_all(CoV2_type, fixed("Spike_IgG"), "A.Spike_IgG")) %>%
  dplyr::mutate(CoV2_type = str_replace_all(CoV2_type, fixed("RBD_IgG"), "B.RBD_IgG")) %>%
  dplyr::mutate(CoV2_type = str_replace_all(CoV2_type, fixed("NC_IgG"), "C.NC_IgG")) %>%
  dplyr::mutate(CoV2_type = str_replace_all(CoV2_type, fixed("Spike_IgA"), "D.Spike_IgA")) %>%
  dplyr::mutate(CoV2_type = str_replace_all(CoV2_type, fixed("RBD_IgA"), "E.RBD_IgA")) %>%
  dplyr::mutate(CoV2_type = str_replace_all(CoV2_type, fixed("NC_IgA"), "F.NC_IgA")) %>%
  ggplot(aes(x = as.numeric(CoV2_signal) , y = CoV2_type, fill=COVID_vaccination_Group)) +
    geom_density_ridges(
      aes(point_color = COVID_vaccination_Group, point_fill = COVID_vaccination_Group, scale = 0.5),
      alpha = .8, point_alpha = 1, jittered_points = TRUE) + #bandwith could be manually adjusted
    ggtitle('All CoV2 grouped') +
    xlab('p(EC50)') +
    ylab('CoV2 isotypes') +
    scale_fill_manual(values=col3) +
    scale_point_color_hue(l = 40) +
    ggplot2:::manual_scale("point_color", values = col3, guide = "none") +
    theme_ridges(grid = FALSE, center = TRUE) +
    geom_vline(xintercept=2, linetype="dashed", 
               color = "red", linewidth=1)

##### Cytokines

subset(cytokines_vertical_z, #Careful, we also use the z-transformed data here, like in the heatmap
              aPL_type == 'CL_IgG' &
              CoV2_type == 'Spike_IgG') %>%
  dplyr::arrange(COVID_vaccination_Group) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("GCSF"), "A.GCSF")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("GMCSF"), "B.GMCSF")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IFNalpha"), "C.IFNalpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IFNgamma"), "D.IFNgamma")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL1beta"), "E.IL1beta")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL4"), "F.IL4")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL6"), "G.IL6")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL8"), "H.IL8")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL10"), "I.IL10")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL17A"), "J.IL17A")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IP10"), "K.IP10")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("MIP1alpha"), "L.MIP1alpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("MIP1beta"), "M.MIP1beta")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("S100A8_A9"), "N.S100A8_A9")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("SDF1alpha"), "O.SDF1alpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("TNFalpha"), "P.TNFalpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("Inflammatory_index"), "Q.Inflammatory_index")) %>%
  ggplot(aes(x = as.numeric(Cytokine_value) , y = Cytokine_signal, fill=COVID_vaccination_Group)) +
    geom_density_ridges(
      aes(point_color = COVID_vaccination_Group, point_fill = COVID_vaccination_Group, scale = 0.5),
      alpha = .8, point_alpha = 1, jittered_points = TRUE) + #bandwith could be manually adjusted
    ggtitle('All Cytokines grouped') +
    xlab('Cytokine signal (Z-Score)') +
    ylab('Cytokine types') +
    scale_fill_manual(values=col3) +
    scale_point_color_hue(l = 40) +
    ggplot2:::manual_scale("point_color", values = col3, guide = "none") +
    theme_ridges(grid = FALSE, center = TRUE)

```

Because of having only 0 values within a column, the following parameters will have to be excluded in a correlational analysis:

-   aPL PC_IgG
-   aPL PE_IgG
-   aPL PC_IgM

Thus, we included 8/10 for IgG, 9/10 for IgM, and 10/10 (all) for IgA in this particular plot.

## We look at the data with PCA using informative groups

```{r DATA EXPLORATION via PCA, fig.height = 10, fig.width = 10}

# aPL
aPL_PCA <- data %>%
  dplyr::select(Unique_sample_ID_for_study,
                COVID_vaccination_Group,
                CL_IgG:PT_IgA) %>%
  na.omit()

groups_PCA_aPL <- as.factor(aPL_PCA$COVID_vaccination_Group[1:141])
names_PCA_aPL <- as.factor(aPL_PCA$Unique_sample_ID_for_study[1:141])

aPL_PCA <- aPL_PCA %>%
  dplyr::select(-Unique_sample_ID_for_study,
                -COVID_vaccination_Group,
                CL_IgG:PT_IgA,
                -PC_IgG, -PE_IgG, -PC_IgM)

rownames(aPL_PCA) <- names_PCA_aPL    

set.seed(42)
aPL_PCA.pca <- prcomp(aPL_PCA, center = TRUE, scale = TRUE)

fviz_pca_biplot(aPL_PCA.pca, 
                label="var",
                geom.var = c("arrow", "text"),
                col.ind=groups_PCA_aPL,
                palette = ("jco"),
                habillage='none',
                addEllipses=FALSE, 
                ellipse.level=0.95,
                repel=TRUE) +
  theme_minimal()

# SARS-CoV-2 antibodies
COV2_PCA <- data %>%
  dplyr::select(Unique_sample_ID_for_study,
                COVID_vaccination_Group,
                Spike_IgG:NC_IgA) %>%
  na.omit()

groups_COV2_PCA <- as.factor(COV2_PCA$COVID_vaccination_Group[1:125])
names_COV2_PCA <- as.factor(COV2_PCA$Unique_sample_ID_for_study[1:125])

COV2_PCA <- COV2_PCA %>%
  dplyr::select(-Unique_sample_ID_for_study,
                -COVID_vaccination_Group,
                Spike_IgG:NC_IgA)

rownames(COV2_PCA) <- names_COV2_PCA   

set.seed(42)
COV2_PCA.pca <- prcomp(COV2_PCA, center = TRUE, scale = TRUE)

fviz_pca_biplot(COV2_PCA.pca, 
                label="var",
                geom.var = c("arrow", "text"),
                col.ind=groups_COV2_PCA,
                palette = ("jco"),
                habillage='none',
                addEllipses=FALSE, 
                ellipse.level=0.95,
                repel=TRUE) +
  theme_minimal()

# Cytokines
Cyto_PCA <- data %>%
  dplyr::select(Unique_sample_ID_for_study,
                COVID_vaccination_Group,
                GCSF:Inflammatory_index) %>%
  na.omit()

groups_PCA <- as.factor(Cyto_PCA$COVID_vaccination_Group[1:112])
names_PCA <- as.factor(Cyto_PCA$Unique_sample_ID_for_study[1:112])

Cyto_PCA <- Cyto_PCA %>%
  dplyr::select(-Unique_sample_ID_for_study,
                -COVID_vaccination_Group,
                GCSF:Inflammatory_index)

rownames(Cyto_PCA) <- names_PCA    

set.seed(42)
Cyto_PCA.pca <- prcomp(Cyto_PCA, center = TRUE, scale = TRUE)

fviz_pca_biplot(Cyto_PCA.pca, 
                label="var",
                geom.var = c("arrow", "text"),
                col.ind=groups_PCA,
                palette = ("jco"),
                habillage='none',
                addEllipses=FALSE, 
                ellipse.level=0.95,
                repel=TRUE) +
  theme_minimal()

```

## We look at the data with PCA using informative groups, by combining all features

```{r DATA EXPLORATION of all data together, fig.height = 10, fig.width = 10}
# We combine all of these features in PCA

All_molecular_PCA <- data %>%
  dplyr::select(Unique_sample_ID_for_study,
                COVID_vaccination_Group,
                GCSF:Inflammatory_index,
                CL_IgG:PT_IgA,
                Spike_IgG:NC_IgA
                ) %>%
  na.omit()

groups_PCA <- as.factor(All_molecular_PCA$COVID_vaccination_Group[1:112])
names_PCA <- as.factor(All_molecular_PCA$Unique_sample_ID_for_study[1:112])

All_molecular_PCA <- All_molecular_PCA %>%
  dplyr::select(-Unique_sample_ID_for_study,
                -COVID_vaccination_Group,
                GCSF:Inflammatory_index,
                CL_IgG:PT_IgA,
                -PC_IgG, -PE_IgG, -PC_IgM,
                Spike_IgG:NC_IgA)

rownames(All_molecular_PCA) <- names_PCA    

set.seed(42)
All_molecular_PCA.pca <- prcomp(All_molecular_PCA, center = TRUE, scale = TRUE)

fviz_pca_biplot(All_molecular_PCA.pca, 
                label="var",
                geom.var = c("arrow", 'text'),
                col.ind=groups_PCA,
                col.var='green',
                palette = ("jco"),
                habillage='none',
                addEllipses=FALSE, 
                ellipse.level=0.95,
                repel=TRUE) +
  theme_minimal()

# For an analysis we conduct later - we aim to find out whether in feature space, we can separate between those individuals with and those without thromboses...

All_molecular_PCA_thrombosis <- data %>%
  dplyr::select(Unique_sample_ID_for_study,
                Thrombosis_group,
                GCSF:Inflammatory_index,
                CL_IgG:PT_IgA,
                Spike_IgG:NC_IgA
                ) %>%
  na.omit()

groups_PCA <- as.factor(All_molecular_PCA_thrombosis$Thrombosis_group[1:112])
names_PCA <- as.factor(All_molecular_PCA_thrombosis$Unique_sample_ID_for_study[1:112])

All_molecular_PCA_thrombosis <- All_molecular_PCA_thrombosis %>%
  dplyr::select(-Unique_sample_ID_for_study,
                -Thrombosis_group,
                GCSF:Inflammatory_index,
                CL_IgG:PT_IgA,
                -PC_IgG, -PE_IgG, -PC_IgM,
                Spike_IgG:NC_IgA)

rownames(All_molecular_PCA_thrombosis) <- names_PCA    

set.seed(42)
All_molecular_PCA_thrombosis.pca <- prcomp(All_molecular_PCA_thrombosis, center = TRUE, scale = TRUE)

fviz_pca_biplot(All_molecular_PCA_thrombosis.pca, 
                label="var",
                geom.var = c("arrow", 'text'),
                col.ind=groups_PCA,
                col.var='green',
                palette = ("jco"),
                habillage='none',
                addEllipses=FALSE, 
                ellipse.level=0.95,
                repel=TRUE) +
  theme_minimal()

```

We observe that 'infected' patients cluster slightly apart from the rest. However, there is no distinction of those with thrombotic events according to molecular features. However, the second analysis is part of another chapter and not of the initial exploratory analysis...

## Extra chapter: stratification of cytokines

As we have so much more cytokine data in the ICU study, we might perform this analysis more extensively in our next study/manuscript. However, using limited data, we can look into cytokine profiles aiming to distinguish between ICU patients with acute influenza and ICU patients with acute COVID-19.

```{r DATA EXPLORATION CYTOKINES, fig.height = 10, fig.width = 10}

# We perform a PCA on the cytokine data and group according to acute infection with influenza or acute infection with SARS-CoV-2

cytokine_PCA_group_acute <- cytokines_z %>%
  dplyr::filter(Acute_infection==TRUE) %>%
  dplyr::select(COVID_vaccination_Group)

cytokine_PCA_group_acute_names <- cytokines_z %>%
  dplyr::filter(Acute_infection==TRUE) %>%
  dplyr::select(Unique_sample_ID_for_study)

cytokine_PCA_group_acute_colours <- cytokines_z %>%
  dplyr::filter(Acute_infection==TRUE) %>%
  dplyr::select(COVID_vaccination_Group) %>% 
  dplyr::mutate(COVID_vaccination_Group = str_replace_all(COVID_vaccination_Group, fixed("00_Influenza_Non-infected/non-vaccinated"), "#0073C299")) %>% 
  dplyr::mutate(COVID_vaccination_Group = str_replace_all(COVID_vaccination_Group, fixed("02_Infected/non-vaccinated"), "#86868699")) %>%
  dplyr::mutate(COVID_vaccination_Group = str_replace_all(COVID_vaccination_Group, fixed("04_Infected/vaccinated"), "#7AA6DC99")) %>%
  as.matrix()

cytokine_PCA_CK_groups <- Cytokines_classifications %>%
  dplyr::select(Cyto_groups) %>%
  dplyr::mutate(Cyto_groups = str_replace_all(Cyto_groups, fixed("Antiinflammatory"), "#eaef55")) %>%
  dplyr::mutate(Cyto_groups = str_replace_all(Cyto_groups, fixed("Proinflammatory"), "#9dcd5e")) %>%
  dplyr::mutate(Cyto_groups = str_replace_all(Cyto_groups, fixed("Mf and T-cells recruitement"), "#61a864")) %>%
  dplyr::mutate(Cyto_groups = str_replace_all(Cyto_groups, fixed("Anti-Pro-inflammatory"), "#398060")) %>%
  dplyr::mutate(Cyto_groups = str_replace_all(Cyto_groups, fixed("Compound"), "#2a584f")) %>%
  as.matrix()

cytokine_PCA_Th_groups <- Cytokines_classifications %>%
  dplyr::select(Th_group) %>%
  dplyr::mutate(Th_group = str_replace_all(Th_group, fixed("Th1"), "#ef55e2")) %>%
  dplyr::mutate(Th_group = str_replace_all(Th_group, fixed("Th2"), "#c151cb")) %>%
    dplyr::mutate(Th_group = str_replace_all(Th_group, fixed("Th_17"), "#974bb2")) %>%
  dplyr::mutate(Th_group = str_replace_all(Th_group, fixed("1_and_2"), "#714295")) %>%
  dplyr::mutate(Th_group = str_replace_all(Th_group, fixed("1_and_17"), "#503777")) %>%
  dplyr::mutate(Th_group = str_replace_all(Th_group, fixed("Compound"), "#342a58")) %>%
  as.matrix()

cytokine_PCA_chemo_groups <- Cytokines_classifications %>%
  dplyr::select(Chemo_cluster) %>%
  dplyr::mutate(Chemo_cluster = str_replace_all(Chemo_cluster, fixed("Key_pro"), "#eba613")) %>%
  dplyr::mutate(Chemo_cluster = str_replace_all(Chemo_cluster, fixed("Key_anti"), "#5a9c42")) %>%
    dplyr::mutate(Chemo_cluster = str_replace_all(Chemo_cluster, fixed("Chemokine"), "#00766f")) %>%
  dplyr::mutate(Chemo_cluster = str_replace_all(Chemo_cluster, fixed("Rest"), "#2a4858")) %>%
  as.matrix()

cytokine_PCA_group_acute = as.factor(cytokine_PCA_group_acute$COVID_vaccination_Group[1:80])
cytokine_PCA_group_acute_names = as.factor(cytokine_PCA_group_acute_names$Unique_sample_ID_for_study[1:80])

set.seed(1)  
cytokines_z %>%
  dplyr::filter(Acute_infection==TRUE) %>%
  dplyr::select(GCSF:Inflammatory_index) %>%
  data.matrix() %>%
  prcomp(center = TRUE, scale = FALSE) %>%
  fviz_pca_biplot(label="var",
                geom.var = c("arrow", 'text'),
                col.ind=cytokine_PCA_group_acute,
                col.var='green',
                palette = (col5),
                habillage='none',
                addEllipses=FALSE, 
                ellipse.level=0.95,
                repel=TRUE) +
  theme_minimal()

# We perform an unsupervised hierarchical clustering on the cytokine data and group according to acute infection with influenza or acute infection with SARS-CoV-2

combined_bars <- cbind(cytokine_PCA_CK_groups, cytokine_PCA_Th_groups, cytokine_PCA_chemo_groups)

# We group according to cytokines
set.seed(1)
cytokines_z %>%
  dplyr::filter(Acute_infection==TRUE) %>%
  dplyr::select(GCSF:Inflammatory_index) %>%
  data.matrix() %>%
  t() %>% dist(method = "euclidean") %>% hclust(method='complete') %>% as.dendrogram -> dend_cyto

par(mar = c(10,2,1,1))
dend_cyto %>%
set("leaves_pch", 19)  %>%
set("nodes_cex", 0.7) %>%
plot()
colored_bars(colors = combined_bars, dend=dend_cyto)

#colored_bars(colors = cytokine_PCA_CK_groups, dend = dend_cyto)

# We group according to individuals
set.seed(1)  
cytokines_z %>%
  dplyr::filter(Acute_infection==TRUE) %>%
  dplyr::select(GCSF:Inflammatory_index) %>%
  data.matrix() %>%
  dist(method = "euclidean") %>% hclust(method='complete') %>% as.dendrogram -> dend_pat

par(mar = c(10,2,1,1))
dend_pat %>% 
set("leaves_pch", 19)  %>% 
set("nodes_cex", 0.7) %>% 
plot()
colored_bars(colors = cytokine_PCA_group_acute_colours, dend = dend_pat)

# We check for statistical differences between the groups, for individual cytokines

cytokines_acute_longer %>%
  dplyr::filter(Acute_infection==TRUE) %>%
  dplyr::arrange(COVID_vaccination_Group) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("GCSF"), "A.GCSF")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("GMCSF"), "B.GMCSF")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IFNalpha"), "C.IFNalpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IFNgamma"), "D.IFNgamma")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL1beta"), "E.IL1beta")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL4"), "F.IL4")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL6"), "G.IL6")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL8"), "H.IL8")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL10"), "I.IL10")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL17A"), "J.IL17A")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IP10"), "K.IP10")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("MIP1alpha"), "L.MIP1alpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("MIP1beta"), "M.MIP1beta")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("S100A8_A9"), "N.S100A8_A9")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("SDF1alpha"), "O.SDF1alpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("TNFalpha"), "P.TNFalpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("Inflammatory_index"), "Q.Inflammatory_index")) %>%
  ggboxplot(x = "COVID_vaccination_Group", y = "Cytokine_value",
    color = "COVID_vaccination_Group", palette=col5, outlier.shape = NA,
    merge = TRUE
  ) +
    geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
    guides(x =  guide_axis(angle = 90)) +
    facet_wrap(~Cytokine_signal, scales='free_y', ncol=9) +
    theme(axis.text.y = element_text(size = 8)) +    
    labs(y="Plasma concentration (pg/ml)",x="",title="")

compare_means(Cytokine_value ~ COVID_vaccination_Group, 
              data=subset(cytokines_acute_longer, Acute_infection==TRUE),
              method = "wilcox", group.by='Cytokine_signal', symnum.args=signifiance_stars, p.adjust.method = "BH")

cytokines_acute_stats <- compare_means(Cytokine_value ~ COVID_vaccination_Group, 
                                       data=subset(cytokines_acute_longer, Acute_infection==TRUE),
                                       method = "wilcox", group.by='Cytokine_signal', 
                                       symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

### We conducted the statistics and the visualisations on the original cytokine data, i.e. concentrations in pg/ml

# And now, we also include some data from other datasets.
#--https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3146842/ (only mean)
#--https://doi.org/10.1016/j.dib.2021.106857 (only mean)
#--https://doi.org/10.4269/ajtmh.20-1110 (only median) -- we do not use this dataset
#--https://www.science.org/doi/10.1126/sciadv.abe3024 (mean and median - we calculated ourselves)
#--Our own ICU cohort study in production (mean and median)
#--The current study (mean and median)

# We only show the cytokines we have been using.

Cytokines_ref %>%
    dplyr::filter(!Cytokine=='EGF') %>%
    dplyr::filter(!Cytokine=='Flt-3L') %>%
    dplyr::filter(!Cytokine=='IL-15') %>%
    dplyr::filter(!Cytokine=='IL-2') %>%
    dplyr::filter(!Cytokine=='MCP 1') %>%
    dplyr::filter(!Cytokine=='PDGF-AA') %>%
    dplyr::filter(!Cytokine=='sCD40L') %>%
    dplyr::filter(!Cytokine=='FGF-2') %>%
    dplyr::filter(!Cytokine=='TGF-α') %>%
    ggboxplot(x = "Main", y = "Mean",
    palette=c('#440154','#414487','#2a788e','#22a884','#7ad151','#fde725'), outlier.shape = NA,
    merge = TRUE
  ) +
    geom_point(shape=16, size=4, position=position_dodge(0.5), aes(color = Study)) +
    geom_errorbar(aes(ymin=(Mean-STDEV), ymax=(Mean+STDEV), colour=Study), width=0.5, position=position_dodge(0.5)) +
    guides(x =  guide_axis(angle = 90)) +
    facet_wrap(~Cytokine, scales='free_y', ncol=8) +
    scale_y_log10() + #As we do a log10 transform to be able to compare the data, some standard deviations that turn negative cannot be properly displayed.
    theme(axis.text.y = element_text(size = 8)) +    
    labs(y="Plasma concentration (pg/ml)",x="",title="")

# We can also show it without log10 axis

Cytokines_ref %>%
    dplyr::filter(!Cytokine=='EGF') %>%
    dplyr::filter(!Cytokine=='Flt-3L') %>%
    dplyr::filter(!Cytokine=='IL-15') %>%
    dplyr::filter(!Cytokine=='IL-2') %>%
    dplyr::filter(!Cytokine=='MCP 1') %>%
    dplyr::filter(!Cytokine=='PDGF-AA') %>%
    dplyr::filter(!Cytokine=='sCD40L') %>%
    dplyr::filter(!Cytokine=='FGF-2') %>%
    dplyr::filter(!Cytokine=='TGF-α') %>%
    ggboxplot(x = "Main", y = "Mean",
    palette=c('#440154','#414487','#2a788e','#22a884','#7ad151','#fde725'), outlier.shape = NA,
    merge = TRUE
  ) +
    geom_point(shape=16, size=4, position=position_dodge(0.5), aes(color = Study)) +
    geom_errorbar(aes(ymin=(Mean-STDEV), ymax=(Mean+STDEV), colour=Study), width=0.5, position=position_dodge(0.5)) +
    guides(x =  guide_axis(angle = 90)) +
    facet_wrap(~Cytokine, scales='free_y', ncol=8) +
    theme(axis.text.y = element_text(size = 8)) +    
    labs(y="Plasma concentration (pg/ml)",x="",title="")

# How do cytokine levels modulate with regard to DPO? We only have DPO data for our dataset...

cytokines_vertical %>%
  dplyr::filter(Isotype == 'IgG' & Target == 'CL') %>%
  dplyr::select(Unique_sample_ID_for_study, Sex, Age, DPOCoV2_or_FLU, Cytokine_signal, Cytokine_value) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("GCSF"), "A.GCSF")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("GMCSF"), "B.GMCSF")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IFNalpha"), "C.IFNalpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IFNgamma"), "D.IFNgamma")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL1beta"), "E.IL1beta")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL4"), "F.IL4")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL6"), "G.IL6")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL8"), "H.IL8")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL10"), "I.IL10")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IL17A"), "J.IL17A")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("IP10"), "K.IP10")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("MIP1alpha"), "L.MIP1alpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("MIP1beta"), "M.MIP1beta")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("S100A8_A9"), "N.S100A8_A9")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("SDF1alpha"), "O.SDF1alpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("TNFalpha"), "P.TNFalpha")) %>%
  dplyr::mutate(Cytokine_signal = str_replace_all(Cytokine_signal, fixed("Inflammatory_index"), "Q.Inflammatory_index")) %>%
  ggplot(aes(x=DPOCoV2_or_FLU, y=Cytokine_value)) +
  geom_point() +
  geom_smooth(method='lm') +
  stat_cor(method='spearman') +
  facet_wrap(~Cytokine_signal, scales='free_y', ncol=9) +
  theme(axis.text.y = element_text(size = 8)) +
  theme_classic() +   
  labs(x="Days post symptom onset",y="Plasma concentration (pg/ml)",title="")

```

A more comprehensive analysis with more data can be performed in the next study.

# COMPARISON WITH PREVIOUS STUDY {.tabset .tabset-fade .tabset-pills}

Can we reproduce the findings from our previous study?

## We use various approaches to compare the data from the previous study

### We compare individual aPLs against each other

#### Restriction to infected/non-vaccinated and non-infected/non-vaccinated

We separate here into different aPL types. Additionally, we only show IgM and IgG as there are no comparable data for IgA. As an additional restriction, we here restrict the analysis to infected/non-vaccinated and non-infected/non-vaccinated, to have the proper comparisons. To do this properly, we quickly enumerate the basic characteristics of the two datasets.

```{r COHORT COMPARISON OLD VS NEW, fig.height = 10, fig.width = 10}

# Age and Sex distributions, for individuals, not samples

Cohort_comparison_sexage <- 
  ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                Isotype == 'IgM' &
                aPL_type == 'PT_IgM' &
                Timepoint == 1), aes(x = dataset, y = as.numeric(Age), color=dataset)) +
  geom_boxplot() +
  geom_point() +
  facet_wrap(~Sex,ncol=2) +
  theme(axis.text.y = element_text(size = 8)) +
  scale_fill_manual(values = c('#E64B35B2', '#4DBBD5B2')) +
  scale_color_manual(values = c('#E64B35B2', '#4DBBD5B2')) +
  labs(y="Age (years)",x="Dataset",title="Comparison of sex and age between datasets")

compare_means(Age ~ dataset, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                Isotype == 'IgM' &
                aPL_type == 'PT_IgM' &
                Timepoint == 1),
                method = "wilcox", group.by = 'Sex', symnum.args=signifiance_stars, p.adjust.method = "BH")

# DPO, for all samples (including repeats)

Cohort_comparison_DPO <-
ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                Isotype == 'IgM' &
                aPL_type == 'PT_IgM'), aes(x = dataset, y = as.numeric(DPOCoV2_or_FLU), color=dataset)) +
  geom_boxplot() +
  geom_point() +
  theme(axis.text.y = element_text(size = 8)) +
  scale_fill_manual(values = c('#E64B35B2', '#4DBBD5B2')) +
  scale_color_manual(values = c('#E64B35B2', '#4DBBD5B2')) +
  labs(y="DPO (days)",x="Dataset",title="Comparison of DPO between datasets")

compare_means(DPOCoV2_or_FLU ~ dataset, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                Isotype == 'IgM' &
                aPL_type == 'PT_IgM'),
                method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH")

# Disease severity, per individual, not samples

Cohort_comparison_severity <-
ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                Isotype == 'IgM' &
                aPL_type == 'PT_IgM' &
                Timepoint == 1), aes(x = SeverityCoV2_or_Flu, color=dataset)) +
  geom_bar(position='dodge', aes(fill=dataset)) +
  theme(axis.text.y = element_text(size = 8)) +
  scale_fill_manual(values = c('#E64B35B2', '#4DBBD5B2')) +
  scale_color_manual(values = c('#E64B35B2', '#4DBBD5B2')) +
  labs(y="Number of individuals",x="Disease severity",title="Comparison of disease severity between datasets")

# Comparison of levels

Cohort_comparison_aPL <-
gghistogram(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                (Isotype == 'IgM' |
                Isotype == 'IgG')),
  x = "aPL_signal", 
  y = "..density..",
  rug = FALSE,
  fill = "COVID_vaccination_Group", 
  palette = c(col2),
  ) +
  facet_grid(rows=vars(Isotype), cols= vars(dataset), scales='free_y', switch='y') +
  theme_classic()
Cohort_comparison_aPL

ggarrange(Cohort_comparison_sexage, Cohort_comparison_DPO, Cohort_comparison_severity, Cohort_comparison_aPL,
          labels = c("A", "B", 'C', 'D'),
          ncol = 2, nrow = 2)
```

The datasets are not fundamentally different in terms of age and sex. However, the range of DPO included is quite different and the disease severity in the new dataset is more drastically dichotomised into 'no disease' and 'severe disease', while in the old dataset, the different categories were quite evenly distributed. This indicates that the comparisons we are now going to perform underlie some potentially meaningful differences, which have to be considered. However, the distributions of IgM and IgG levels are largely comparable between the datasets (see statistical analyses).

```{r COMP ISOTYPE OLD NEW INDIV NO IGA ONLY INFECTED VS NON-INFECTED, fig.height = 10, fig.width = 10}

subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                 (Isotype == 'IgM' |
                    Isotype == 'IgG')) %>%
  dplyr::arrange(COVID_vaccination_Group) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("CL_IgG"), "A.CL_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PA_IgG"), "B.PA_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PC_IgG"), "C.PC_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PE_IgG"), "D.PE_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PG_IgG"), "E.PG_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PI_IgG"), "F.PI_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PS_IgG"), "G.PS_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("AnnV_IgG"), "H.AnV_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("ß2GF.PI_IgG"), "I.ß2GPI_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PT_IgG"), "J.PT_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("CL_IgM"), "K.CL_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PA_IgM"), "L.PA_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PC_IgM"), "M.PC_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PE_IgM"), "N.PE_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PG_IgM"), "O.PG_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PI_IgM"), "P.PI_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PS_IgM"), "Q.PS_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("AnnV_IgM"), "R.AnV_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("ß2GP.PI_IgM"), "S.ß2GPI_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PT_IgM"), "T.PT_IgM")) %>%
  ggplot(aes(x = aPL_type, y = as.numeric(aPL_signal))) +
    geom_boxplot(aes(color = dataset), outlier.shape = NA, add = "mean") +
    geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = dataset)) +
    geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
    stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
                 aes(group = interaction(aPL_type, dataset)), color = "darkred",
                 position = position_dodge(width = 0.8)) +
    stat_summary(fun = mean, colour = "red", 
                 position = position_dodge(width = 0.8),
                 geom = "text", vjust = -0.7, 
                 aes(label = round(..y.., digits = 1), group = interaction(aPL_type, dataset))) +
    scale_color_npg() +
    guides(x =  guide_axis(angle = 90)) +
    theme_classic()

subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                 (Isotype == 'IgM' |
                    Isotype == 'IgG')) %>%
  dplyr::arrange(COVID_vaccination_Group) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("CL_IgG"), "A.CL_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PA_IgG"), "B.PA_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PC_IgG"), "C.PC_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PE_IgG"), "D.PE_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PG_IgG"), "E.PG_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PI_IgG"), "F.PI_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PS_IgG"), "G.PS_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("AnnV_IgG"), "H.AnV_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("ß2GF.PI_IgG"), "I.ß2GPI_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PT_IgG"), "J.PT_IgG")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("CL_IgM"), "K.CL_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PA_IgM"), "L.PA_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PC_IgM"), "M.PC_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PE_IgM"), "N.PE_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PG_IgM"), "O.PG_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PI_IgM"), "P.PI_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PS_IgM"), "Q.PS_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("AnnV_IgM"), "R.AnV_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("ß2GP.PI_IgM"), "S.ß2GPI_IgM")) %>%
  dplyr::mutate(aPL_type = str_replace_all(aPL_type, fixed("PT_IgM"), "T.PT_IgM")) %>%
  ggplot(aes(x = as.numeric(aPL_signal) , y = aPL_type, fill=dataset)) +
    geom_density_ridges(
      aes(point_color = dataset, point_fill = dataset, scale = 0.5),
      alpha = .8, point_alpha = 1, jittered_points = TRUE) + #bandwith could be manually adjusted
    ggtitle('All aPL grouped by aPL types') +
    xlab('aPL signal') +
    ylab('aPL types') +
    scale_color_npg() +
    scale_point_color_hue(l = 40) +
    ggplot2:::manual_scale("point_color", values = c('#E64B35B2', '#4DBBD5B2'), guide = "none") +
    theme_ridges(grid = FALSE, center = TRUE) +
    geom_vline(xintercept=50, linetype="dashed", 
               color = "red", linewidth=1)

```

Observations:

-   The pattern look quite similar between the previously published (old) and the new datasets.
-   We, here, look only at infected AND non-infected previously published (old) versus new dataset, split for all aPL.

#### Female:male ratio

```{r COMP ALL APL NOT INDIVIDUAL FEMALE-MALE RATIO, fig.height = 10, fig.width = 10}
# All samples, including repeats

table1(~ Age + Sex + COVID_vaccination_Group
       | dataset,
       render.continuous = render.cont, render.categorical = render.cat, 
       data = subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                Isotype == 'IgM' &
                aPL_type == 'PT_IgM'))

# Unique patients

table1(~ Age + Sex + COVID_vaccination_Group
       | dataset,
       render.continuous = render.cont, render.categorical = render.cat, 
       data = subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                Isotype == 'IgM' &
                aPL_type == 'PT_IgM' &
                Timepoint==1))
```

### We compare all aPLs against each other, not individual ones

#### We compare infected versus non infected in the current dataset versus the previous dataset

We compare between old and new, for non-infected/non-vaccinated (control) and for infected/non-vaccinated groups. Is there a difference between old and new datasets?

```{r COMP ALL APL NOT INDIVIDUAL STATS, fig.height = 10, fig.width = 10}
# We first do the statistics for IgM
compare_means(aPL_signal ~ dataset, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                            (Isotype == 'IgM')),
              method = "wilcox", group.by = 'COVID_vaccination_Group', symnum.args=signifiance_stars, p.adjust.method = "BH")

# We then do the statistics for IgG
compare_means(aPL_signal ~ dataset, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                            (Isotype == 'IgG')),
              method = "wilcox", group.by = 'COVID_vaccination_Group', symnum.args=signifiance_stars, p.adjust.method = "BH")
```

Observations:

-   The infected/non-vaccinated group is not statistically different between old and new (IgM).
-   The non-infected/non-vaccinated group is statistically significant between old and new (IgM).
-   The infected/non-vaccinated group is not statistically different between old and new (IgG).
-   The non-infected/non-vaccinated group is statistically significant between old and new (IgG).

```{r COMP ALL APL NOT INDIVIDUAL, fig.height = 10, fig.width = 10}
# We visualise
ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
  (Isotype == 'IgM' |
  Isotype == 'IgG')), aes(x = interaction(Isotype, COVID_vaccination_Group), y = as.numeric(aPL_signal))) +
  geom_boxplot(aes(color = dataset), outlier.shape = NA, add = "mean") +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = dataset)) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
               aes(group = interaction(Isotype, dataset, COVID_vaccination_Group)), color = "darkred",
               position = position_dodge(width = 0.8)) +
  stat_summary(fun = mean, colour = "red", 
               position = position_dodge(width = 0.8),
               geom = "text", vjust = -0.7, 
               aes(label = round(..y.., digits = 1), group = interaction(Isotype, dataset, COVID_vaccination_Group))) +
  scale_color_npg() +
  guides(x =  guide_axis(angle = 90)) +
  theme_classic()
```

We conclude, here, that in terms of overall reactivity, the previously published (old) and the current (new) datasets are comparable as they do not display a statistically significant difference among the infected individuals. However, the baseline, i.e. aPL values measured in non-infected individuals, is different between the two datasets, with higher values in the old dataset on average.

#### We compare between non-infected/non-vaccinated and infected/non-vaccinated groups, for old and new and different isotypes

The question we pose here is already more interesting: Is there a difference between non-infected/non-vaccinated and infected/non-vaccinated groups?

```{r COMP ALL APL NOT INDIVIDUAL INFECTED VS NON-INFECTED STATS, fig.height = 10, fig.width = 10}
# We first do the statistics for IgM
compare_means(aPL_signal ~ COVID_vaccination_Group, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                            (Isotype == 'IgM')),
              method = "wilcox", group.by = 'dataset', symnum.args=signifiance_stars, p.adjust.method = "BH")

# We then do the statistics for IgG
compare_means(aPL_signal ~ COVID_vaccination_Group, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                            (Isotype == 'IgG')),
              method = "wilcox", group.by = 'dataset', symnum.args=signifiance_stars, p.adjust.method = "BH")
```

Observations:

-   The new but not the old dataset displays significant distributional differences in terms of IgM infected versus non-infected.
-   Both old and new datasets are significantly different in terms of IgG infected versus non-infected.

```{r COMP ALL APL NOT INDIVIDUAL INFECTED VS NON-INFECTED, fig.height = 10, fig.width = 10}
# We visualise
ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                (Isotype == 'IgM' |
                   Isotype == 'IgG')), aes(x = interaction(Isotype, dataset), y = as.numeric(aPL_signal))) +
  geom_boxplot(aes(color = COVID_vaccination_Group), outlier.shape = NA, add = "mean") +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
               aes(group = interaction(Isotype, dataset, COVID_vaccination_Group)), color = "darkred",
               position = position_dodge(width = 0.8)) +
  stat_summary(fun = mean, colour = "red", 
               position = position_dodge(width = 0.8),
               geom = "text", vjust = -0.7, 
               aes(label = round(..y.., digits = 1), group = interaction(Isotype, dataset, COVID_vaccination_Group))) +
  scale_color_manual(values=c(col2)) +
  guides(x =  guide_axis(angle = 90)) +
  theme_classic()

ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                (Isotype == 'IgM' |
                   Isotype == 'IgG')), aes(x = as.numeric(aPL_signal) , y = interaction(Isotype, dataset), fill=COVID_vaccination_Group)) +
  geom_density_ridges(
    aes(point_color = COVID_vaccination_Group, point_fill = COVID_vaccination_Group, scale = 0.5),
    alpha = .8, point_alpha = 1, jittered_points = TRUE) + #bandwith could be manually adjusted
  ggtitle('All aPL grouped by aPL types') +
  xlab('aPL signal') +
  ylab('aPL types') +
  scale_fill_manual(values=c(col2)) +
  scale_point_color_hue(l = 40) +
  ggplot2:::manual_scale("point_color", values = col2, guide = "none") +
  theme_ridges(grid = FALSE, center = TRUE) +
  geom_vline(xintercept=50, linetype="dashed", 
             color = "red", linewidth=1)
```

Here, we conclude that in line with what we had observed in our previous study, we see that aPL are enriched in individuals following infection with SARS-CoV-2, both regarding IgM as well as IgG aPL.

### We have focused on Prothrombin in the previous study - look at PT particularly, also include B2GPI and AnV

We have a particular interest in looking into Prothrombin aPL as PT has turned out to be the major finding in the previous study. Here, we follow the same approach as above when all aPL were included.

#### Old versus new

```{r COMP PT OLD VS NEW STATS, fig.height = 10, fig.width = 10}
# We first do the statistics for IgM
compare_means(aPL_signal ~ dataset, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                          (Isotype == 'IgM') &
                          (Target == 'PT')),
              method = "wilcox", group.by = 'COVID_vaccination_Group', symnum.args=signifiance_stars, p.adjust.method = "BH")

# We then do the statistics for IgG
compare_means(aPL_signal ~ dataset, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                            (Isotype == 'IgG') &
                            (Target == 'PT')),
              method = "wilcox", group.by = 'COVID_vaccination_Group', symnum.args=signifiance_stars, p.adjust.method = "BH")
```

Observations:

-   New and old datasets differ for the infected/non-vaccinated group in PT levels (IgM and IgG).
-   New and old datasets do not differ for the non-infected/non-vaccinated group in PT levels (IgM and IgG).

```{r COMP PT OLD VS NEW, fig.height = 10, fig.width = 10}
# We visualise
ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
              (Isotype == 'IgM' |
               Isotype == 'IgG') &
              (Target == 'PT')), 
       aes(x = interaction(Isotype, COVID_vaccination_Group), y = as.numeric(aPL_signal))) +
  geom_boxplot(aes(color = dataset), outlier.shape = NA, add = "mean") +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = dataset)) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
               aes(group = interaction(Isotype, dataset, COVID_vaccination_Group)), color = "darkred",
               position = position_dodge(width = 0.8)) +
  stat_summary(fun = mean, colour = "red", 
               position = position_dodge(width = 0.8),
               geom = "text", vjust = -0.7, 
               aes(label = round(..y.., digits = 1), group = interaction(Isotype, dataset, COVID_vaccination_Group))) +
  scale_color_npg() +
  guides(x =  guide_axis(angle = 90)) +
  theme_classic()
```

We conclude that the PT measurements for both IgM and IgG yielded higher values in the old versus the new dataset throughout, in both infected and in non-infected individuals.

#### Statistics non-infected/non-vaccinated versus infected/non-vaccinated PT

```{r COMP PT INFECTED VS NON-INFECTED STATS, fig.height = 10, fig.width = 10}
# We first do the statistics for IgM
compare_means(aPL_signal ~ COVID_vaccination_Group, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                          (Isotype == 'IgM') &
                          (Target == 'PT')),
              method = "wilcox", group.by = 'dataset', symnum.args=signifiance_stars, p.adjust.method = "BH")

# We then do the statistics for IgG
compare_means(aPL_signal ~ COVID_vaccination_Group, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                            (Isotype == 'IgG') &
                            (Target == 'PT')),
              method = "wilcox", group.by = 'dataset', symnum.args=signifiance_stars, p.adjust.method = "BH")

```

Observations:

-   Old and new dataset display significant difference infected versus non-infected PT (IgM).
-   Old and new dataset display no significant difference infected versus non-infected PT (IgG).

```{r COMP PT INFECTED VS NON-INFECTED, fig.height = 10, fig.width = 10}
# We visualise
ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
              (Isotype == 'IgM' |
               Isotype == 'IgG') &
              (Target == 'PT')), 
       aes(x = interaction(Isotype, dataset), y = as.numeric(aPL_signal))) +
  geom_boxplot(aes(color = COVID_vaccination_Group), outlier.shape = NA, add = "mean") +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
               aes(group = interaction(Isotype, dataset, COVID_vaccination_Group)), color = "darkred",
               position = position_dodge(width = 0.8)) +
  stat_summary(fun = mean, colour = "red", 
               position = position_dodge(width = 0.8),
               geom = "text", vjust = -0.7, 
               aes(label = round(..y.., digits = 1), group = interaction(Isotype, dataset, COVID_vaccination_Group))) +
  scale_color_manual(values=c(col2)) +
  guides(x =  guide_axis(angle = 90)) +
  theme_classic()
```

We conclude that, importantly, one of the principal findings from our previous study is validated: We observe a significant difference in infected versus non-infected individuals for PT IgM, but not for IgG, in the new dataset, as seen in the old already published dataset. 

#### Statistics non-infected/non-vaccinated versus infected/non-vaccinated B2GPI

```{r COMP ß2GPI INFECTED VS NON-INFECTED STATS, fig.height = 10, fig.width = 10}
# We first do the statistics for IgM
compare_means(aPL_signal ~ COVID_vaccination_Group, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                          (Isotype == 'IgM') &
                          (Target == 'ß2GPI')),
              method = "wilcox", group.by = 'dataset', symnum.args=signifiance_stars,p.adjust.method = "BH")

# We then do the statistics for IgG
compare_means(aPL_signal ~ COVID_vaccination_Group, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                            (Isotype == 'IgG') &
                            (Target == 'ß2GPI')),
              method = "wilcox", group.by = 'dataset', symnum.args=signifiance_stars,p.adjust.method = "BH")
```

Observations:

-   Differences between infected and non-infected patients in IgG are slightly significant in the new, but not in the old dataset, for IgG.
-   Differences between infected and non-infected patients in IgM, in the new or old dataset, are significant, and the significance is more robust in the new dataset.

```{r COMP ß2GPI INFECTED VS NON-INFECTED, fig.height = 10, fig.width = 10}
# We visualise
ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
              (Isotype == 'IgM' |
               Isotype == 'IgG') &
              (Target == 'ß2GPI')), 
       aes(x = interaction(Isotype, dataset), y = as.numeric(aPL_signal))) +
  geom_boxplot(aes(color = COVID_vaccination_Group), outlier.shape = NA, add = "mean") +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
               aes(group = interaction(Isotype, dataset, COVID_vaccination_Group)), color = "darkred",
               position = position_dodge(width = 0.8)) +
  stat_summary(fun = mean, colour = "red", 
               position = position_dodge(width = 0.8),
               geom = "text", vjust = -0.7, 
               aes(label = round(..y.., digits = 1), group = interaction(Isotype, dataset, COVID_vaccination_Group))) +
  scale_color_manual(values=c(col2)) +
  guides(x =  guide_axis(angle = 90)) +
  theme_classic()
```

#### Statistics non-infected/non-vaccinated versus infected/non-vaccinated AnV

```{r COMP AnV INFECTED VS NON-INFECTED STATS, fig.height = 10, fig.width = 10}
# We first do the statistics for IgM
compare_means(aPL_signal ~ COVID_vaccination_Group, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                          (Isotype == 'IgM') &
                          (Target == 'AnnV')),
              method = "wilcox", group.by = 'dataset', symnum.args=signifiance_stars, p.adjust.method = "BH")

# We then do the statistics for IgG
compare_means(aPL_signal ~ COVID_vaccination_Group, 
              data=subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
                            (Isotype == 'IgG') &
                            (Target == 'AnnV')),
              method = "wilcox", group.by = 'dataset', symnum.args=signifiance_stars, p.adjust.method = "BH")
```

Observations:

-   Differences between infected and non-infected patients in IgG, in the new or old dataset, are not significant. This confirms previous results.
-   AnV, in our previous publication, was significantly different in infected versus non-infected individuals after binarisation of the dataset, with Fisher's exact test. However, the distributions were not significantly different using Wilcoxon rank sum test after BH correction. In the new dataset, the distributions are significantly different also with Wilcoxon rank sum test. This confirms the previous observation that AnV is enriched in patients with/after infection with SARS-CoV-2.

```{r COMP AnV INFECTED VS NON-INFECTED, fig.height = 10, fig.width = 10}
# We visualise
ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
              (Isotype == 'IgM' |
               Isotype == 'IgG') &
              (Target == 'AnnV')), 
       aes(x = interaction(Isotype, dataset), y = as.numeric(aPL_signal))) +
  geom_boxplot(aes(color = COVID_vaccination_Group), outlier.shape = NA, add = "mean") +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
               aes(group = interaction(Isotype, dataset, COVID_vaccination_Group)), color = "darkred",
               position = position_dodge(width = 0.8)) +
  stat_summary(fun = mean, colour = "red", 
               position = position_dodge(width = 0.8),
               geom = "text", vjust = -0.7, 
               aes(label = round(..y.., digits = 1), group = interaction(Isotype, dataset, COVID_vaccination_Group))) +
  scale_color_manual(values=c(col2)) +
  guides(x =  guide_axis(angle = 90)) +
  theme_classic()
```

```{r COMP PT B2GPI AnV INFECTED VS NON-INFECTED ALL TOGETHER, message=FALSE, warning=FALSE, fig.height = 10, fig.width = 10}
# We visualise

comp_PT_B2GPI_AnV <-
ggplot(subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
              (Isotype == 'IgM' |
               Isotype == 'IgG') &
              (Target == 'PT' |
                Target == 'ß2GPI' |
                Target == 'AnnV')), 
       aes(x = interaction(Isotype, dataset), y = as.numeric(aPL_signal))) +
  geom_boxplot(aes(color = COVID_vaccination_Group), outlier.shape = NA, add = "mean") +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
               aes(group = interaction(Isotype, dataset, COVID_vaccination_Group)), color = "darkred",
               position = position_dodge(width = 0.8)) +
  stat_summary(fun = mean, colour = "red", 
               position = position_dodge(width = 0.8),
               geom = "text", vjust = -0.7, 
               aes(label = round(..y.., digits = 1), group = interaction(Isotype, dataset, COVID_vaccination_Group))) +
  scale_color_manual(values=c(col2)) +
  guides(x =  guide_axis(angle = 90)) +
  facet_wrap(~Target,ncol=3) +
  theme(axis.text.y = element_text(size = 8)) +
  labs(y="aPL level",x="",title="Comparison infected versus non-infected in old and new datasets") +
  theme_classic()
comp_PT_B2GPI_AnV

comp_PT_B2GPI_AnV_hist <-
subset(published_data_comparison_NA, 
               (COVID_vaccination_Group == '01_Non-infected/non-vaccinated' |
                COVID_vaccination_Group == '02_Infected/non-vaccinated') &
              (Isotype == 'IgM' |
               Isotype == 'IgG') &
              (Target == 'PT' |
                Target == 'ß2GPI' |
                Target == 'AnnV')) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("AnnV"), "C.AnV")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("ß2GPI"), "B.ß2GPI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PT"), "A.PT")) %>%
  gghistogram(x = "aPL_signal", 
    y = "..density..",
    #add = "mean", 
    rug = FALSE,
    fill = "COVID_vaccination_Group", 
    palette = c(col2),
    #add_density = TRUE
    ) +
    facet_grid(rows=vars(Isotype), cols= vars(Target, dataset), scales='free_y', switch='y') +
    theme(axis.text.y = element_text(size = 8)) +
    labs(y="Density",x="aPL level",title="") +
    theme(legend.position = 'none')

ggarrange(Cohort_comparison_sexage, Cohort_comparison_DPO, Cohort_comparison_severity, Cohort_comparison_aPL, comp_PT_B2GPI_AnV_hist,
          labels = c("A", "B", 'C', 'D', 'E'),
          ncol = 2, nrow = 3)

```

## Are they modulated by the strength of the antibody response against SARS-CoV-2 proteins?

### We plot the overall aPL as a function of PC1_IgG and PC1_IgA.

```{r overall aPL PC1_IgG and PC1_IGA, fig.height = 10, fig.width = 10}

# Variant 1
aPL_PC1_IgG <-
 ggplot(data=subset(data_vertical, CoV2_type == 'Spike_IgG'), aes(x = PC1_IgG, y = aPL_signal, color=Isotype)) +
  geom_point() +
  geom_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype)) +
  stat_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype), lty='dotted', geom='ribbon', fill=NA) +
  stat_cor(method='spearman') +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  scale_fill_manual(values=c(col4)) +
  scale_color_manual(values=c(col4)) +
  theme(axis.text.y = element_text(size = 8)) +
  labs(y="aPL signal",x="anti-Sars-CoV-2 PC1 IgG",title="all aPL versus SARS-CoV-2 PC1 IgG")
aPL_PC1_IgG

# Variant 2
ggscatter(
  data=subset(data_vertical, CoV2_type == 'Spike_IgG'), 
  x = "PC1_IgG", 
  y = "aPL_signal",
  color = "Isotype", 
  palette = c(col4),
  add = "reg.line",
  cor.method = 'spearman'
) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_cor(aes(color = Isotype),method='spearman') +
  labs(y="aPL signal",x="anti-Sars-CoV-2 PC1 IgG",title="all aPL versus SARS-CoV-2 PC1 IgG") +
  theme_classic()
aPL_PC1_IgG

# Variant 1
aPL_PC1_IgA <-
 ggplot(data=subset(data_vertical, CoV2_type == 'Spike_IgG'), aes(x = PC1_IgA, y = aPL_signal, color=Isotype)) +
  geom_point() +
  geom_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype)) +
  stat_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype), lty='dotted', geom='ribbon', fill=NA) +
  stat_cor(method='spearman') +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  scale_fill_manual(values=c(col4)) +
  scale_color_manual(values=c(col4)) +
  theme(axis.text.y = element_text(size = 8)) +
  labs(y="aPL signal",x="anti-Sars-CoV-2 PC1 IgA",title="all aPL versus SARS-CoV-2 PC1 IgA")
aPL_PC1_IgA
  
# Variant 2
ggscatter(
  data=subset(data_vertical, CoV2_type == 'Spike_IgG'), 
  x = "PC1_IgA", 
  y = "aPL_signal",
  color = "Isotype", 
  palette = c(col4),
  add = "reg.line",
  cor.method = 'spearman'
) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_cor(aes(color = Isotype),method='spearman') +
  labs(y="aPL signal",x="anti-SARS-CoV-2 PC1 IgA",title="all aPL versus SARS-CoV-2 PC1 IgA") +
  theme_classic()
aPL_PC1_IgA

```

Observations:

-   aPL IgG, IgA, and IgM, in general, do not show a linear correlation with anti-SARS-CoV-2 IgG.
-   aPL IgG, IgA, and IgM, in general, do not show a linear correlation with anti-SARS-CoV-2 IgA.

### We plot PT, B2GPI, AnV, and CL specifically as a function of PC1_IgG and PC1_IGA.

```{r PT, B2GPI, AnV, and CL aPL PC1_IgG and PC1_IGA, fig.height = 10, fig.width = 10}

# Variant 1
PTB2GPIAnV_PC1_IgG <-
subset(data_vertical, 
              CoV2_type == 'Spike_IgG' & 
              Target == 'PT' |
              Target == 'ß2GPI' |
              Target == 'AnnV' |
              Target == 'CL') %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("AnnV"), "C.AnV")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("ß2GPI"), "B.ß2GPI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PT"), "A.PT")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("CL"), "D.CL")) %>%  
 ggplot(aes(x = PC1_IgG, y = aPL_signal, color=Isotype)) +
  geom_point() +
  geom_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype)) +
  stat_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype), lty='dotted', geom='ribbon', fill=NA) +
  stat_cor(method='spearman') +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  scale_fill_manual(values=c(col4)) +
  scale_color_manual(values=c(col4)) +
  facet_wrap(~Target,ncol=4) +
  theme(axis.text.y = element_text(size = 8)) +
  labs(y="aPL signal",x="anti-Sars-CoV-2 PC1 IgG",title="PT, B2GPI, AnV, and CL aPL versus SARS-CoV-2 PC1 IgG")
PTB2GPIAnV_PC1_IgG

# Variant 2
subset(data_vertical, 
              CoV2_type == 'Spike_IgG' & 
              Target == 'PT' |
              Target == 'ß2GPI' |
              Target == 'AnnV' |
              Target == 'CL') %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("AnnV"), "C.AnV")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("ß2GPI"), "B.ß2GPI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PT"), "A.PT")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("CL"), "D.CL")) %>%  
  ggscatter( 
    x = "PC1_IgG", 
    y = "aPL_signal",
    color = "Isotype", 
    palette = c(col4),
    add = "reg.line",
    cor.method = 'spearman'
    ) +
    geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
    stat_cor(aes(color = Isotype), method='spearman') +
    facet_wrap(~Target,ncol=4) +
    labs(y="aPL signal",x="anti-Sars-CoV-2 PC1 IgG",title="PT, B2GPI, AnV, and CL aPL versus SARS-CoV-2 PC1 IgG") +
    theme_classic()

# Variant 1
PTB2GPIAnV_PC1_IgA <-
subset(data_vertical, 
              CoV2_type == 'Spike_IgG' & 
              Target == 'PT' |
              Target == 'ß2GPI' |
              Target == 'AnnV' |
              Target == 'CL') %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("AnnV"), "C.AnV")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("ß2GPI"), "B.ß2GPI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PT"), "A.PT")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("CL"), "D.CL")) %>%  
 ggplot(aes(x = PC1_IgA, y = aPL_signal, color=Isotype)) +
  geom_point() +
  geom_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype)) +
  stat_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype), lty='dotted', geom='ribbon', fill=NA) +
  stat_cor(method='spearman') +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  scale_fill_manual(values=c(col4)) +
  scale_color_manual(values=c(col4)) +
  facet_wrap(~Target,ncol=4) +
  theme(axis.text.y = element_text(size = 8)) +
  labs(y="aPL signal",x="anti-Sars-CoV-2 PC1 IgA",title="PT, B2GPI, AnV, and CL aPL versus SARS-CoV-2 PC1 IgA")
PTB2GPIAnV_PC1_IgA

# Variant 2
subset(data_vertical, 
              CoV2_type == 'Spike_IgG' & 
              Target == 'PT' |
              Target == 'ß2GPI' |
              Target == 'AnnV' |
              Target == 'CL') %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("AnnV"), "C.AnV")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("ß2GPI"), "B.ß2GPI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PT"), "A.PT")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("CL"), "D.CL")) %>%  
  ggscatter( 
            x = "PC1_IgA", 
            y = "aPL_signal",
            color = "Isotype", 
            palette = c(col4),
            add = "reg.line",
            cor.method = 'spearman'
    ) +
    geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
    stat_cor(aes(color = Isotype),method='spearman') +
    facet_wrap(~Target,ncol=4) +
    labs(y="aPL signal",x="anti-Sars-CoV-2 PC1 IgA",title="PT, B2GPI, AnV, and CL aPL versus SARS-CoV-2 PC1 IgA") +
    theme_classic()


ggarrange(aPL_PC1_IgG, aPL_PC1_IgA, PTB2GPIAnV_PC1_IgG, PTB2GPIAnV_PC1_IgA,
          labels = c("A", "B", 'C', 'D'),
          ncol = 2, nrow = 2)
```

### We plot PT, B2GPI, and AnV specifically as a function of age and sex.

```{r PT, B2GPI, AnV, CL aPL AGE and SEX, fig.height = 10, fig.width = 10}

# Variant 1
subset(data_vertical, 
              CoV2_type == 'Spike_IgG' & 
              Target == 'PT' |
              Target == 'ß2GPI' |
              Target == 'AnnV' |
              Target == 'CL') %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("AnnV"), "C.AnV")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("ß2GPI"), "B.ß2GPI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PT"), "A.PT")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("CL"), "D.CL")) %>%  
 ggplot(aes(x = Age, y = aPL_signal, color=Isotype)) +
  geom_point() +
  geom_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype)) +
  stat_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype), lty='dotted', geom='ribbon', fill=NA) +
  stat_cor(method='spearman') +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  scale_fill_manual(values=c(col4)) +
  scale_color_manual(values=c(col4)) +
  facet_wrap(~Target,ncol=4) +
  theme(axis.text.y = element_text(size = 8)) +
  labs(y="aPL signal",x="anti-Sars-CoV-2 PC1 IgA",title="PT, B2GPI, and AnV aPL versus SARS-CoV-2 PC1 IgA")

# Variant 2
subset(data_vertical, 
              CoV2_type == 'Spike_IgG' & 
              Target == 'PT' |
              Target == 'ß2GPI' |
              Target == 'AnnV' |
              Target == 'CL') %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("AnnV"), "C.AnV")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("ß2GPI"), "B.ß2GPI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PT"), "A.PT")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("CL"), "D.CL")) %>%  
  ggscatter(
  x = "Age", 
  y = "aPL_signal",
  color = "Isotype",
  shape='Sex',
  palette = c(col4),
  add = "reg.line",
  cor.method = 'spearman'
  ) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_cor(aes(color = Isotype), method='spearman') +
  facet_wrap(~Target,ncol=4) +
  labs(y="aPL signal",x="Age",title="PT, B2GPI, and AnV aPL versus Age") +
  theme_classic()

```

## Are there other factors that influence the aPL levels (in line or not with previous finding)?

We obviously focus on PT_IgM, B2GPI_IgM, AnV_IgM, and CL IgG.

### We shape the data for regression

```{r DATA SHAPING FOR REGRESSION, fig.height = 10, fig.width = 10}
data_aPL_regr <- data %>% 
  dplyr::select(Unique_sample_ID_for_study,
                Thrombosis_group,
                CL_IgG:PT_IgA, aPL_IgG_rowmean:aPL_IgA_rowmean,
                Spike_IgG:NC_IgA, PC1_IgG, PC1_IgA,
                GCSF:Inflammatory_index,
                Sex, Age,
                SeverityCoV2_or_Flu, Acute_SARS_CoV_2_infection,
                Anticoagulation.at.event, Anticoagulation.chronic,
                Platelet.aggregation.inhibitor.at.event, Platelet.aggregation.inhibitor.chronic,
                Immunosuppressed_admission, Vaccination_statusonly_CoV2
  ) %>% 
  dplyr::mutate(Age=(Age-mean(Age))/sd(Age)
  ) %>%
  na.omit() # We remove those patients/samples with missing (NA) values. This has consequences for later and is annotated there as well.

data_aPL_regr$SeverityCoV2_or_Flu_int <- as.numeric(gsub("\\D", "", data_aPL_regr$SeverityCoV2_or_Flu)) # We want to use this as a score
data_aPL_regr$SeverityCoV2_or_Flu_int = as.numeric(data_aPL_regr$SeverityCoV2_or_Flu_int)

data_aPL_regr <- data_aPL_regr %>% 
  dplyr::select(-SeverityCoV2_or_Flu)

data_aPL_regr$Vaccination_statusonly_CoV2 = as.numeric(data_aPL_regr$Vaccination_statusonly_CoV2)
data_aPL_regr$Thrombosis_group = as.numeric(data_aPL_regr$Thrombosis_group)

data_aPL_regr_plot_PT_IgM <- data_aPL_regr %>% 
  dplyr::filter(PT_IgM > 1)

data_aPL_regr_plot_AnV_IgM <- data_aPL_regr %>% 
  dplyr::filter(AnnV_IgM > 1)

data_aPL_regr_plot_B2GPI_IgM <- data_aPL_regr %>% 
  dplyr::filter(ß2GPI_IgM > 1)

data_aPL_regr_plot_CL_IgG <- data_aPL_regr %>% 
  dplyr::filter(CL_IgG > 1)

```

### We investigate the features using Boruta

We explain Boruta in depth in another chapter. Quintessentially, we conduct a random forest regression to identify which of the parameters are important for predicting the outcome, in this case PT, B2GPI, or AnV IgM.

```{r USING BORUTA TO INVESTIGATE FEATURES FOR MODEL, message=FALSE, warning=FALSE, fig.height = 10, fig.width = 10}
set.seed(1)

# PT_IgM

boruta_PT_IgM <- Boruta(PT_IgM ~ PC1_IgG + PC1_IgA +
                          Spike_IgG + RBD_IgG + NC_IgG + 
                          Spike_IgA + RBD_IgA + NC_IgA +
                          GCSF + GMCSF + IFNalpha + IFNgamma + IL1beta + IL4 + IL6 + IL8 + IL10 + IL17A + IP10 + MIP1alpha +
                          MIP1beta + S100A8_A9 + SDF1alpha + TNFalpha + Inflammatory_index +
                          Acute_SARS_CoV_2_infection + 
                          Anticoagulation.at.event + 
                          Platelet.aggregation.inhibitor.at.event +
                          Immunosuppressed_admission +
                          Vaccination_statusonly_CoV2 +
                          SeverityCoV2_or_Flu_int + 
                          Sex + Age,
                        data=na.omit(data_aPL_regr), doTrace=2, maxRuns=1000)  # perform Boruta search

boruta_PT_IgM_signif <- names(boruta_PT_IgM$finalDecision[boruta_PT_IgM$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
print(boruta_PT_IgM_signif)  # significant variables

plot(boruta_PT_IgM, cex.axis=.5, las=2, xlab="", main="Variable Importance PT IgM all")  # plot variable importance

boruta_PT_IgM_02 <- Boruta(PT_IgM ~ PC1_IgG + PC1_IgA +
                          Spike_IgG + RBD_IgG + NC_IgG + 
                          Spike_IgA + RBD_IgA + NC_IgA +
                          GCSF + GMCSF + IFNalpha + IFNgamma + IL1beta + IL4 + IL6 + IL8 + IL10 + IL17A + IP10 + MIP1alpha +
                          MIP1beta + S100A8_A9 + SDF1alpha + TNFalpha + Inflammatory_index +
                          Acute_SARS_CoV_2_infection + 
                          Anticoagulation.at.event + 
                          Platelet.aggregation.inhibitor.at.event +
                          Immunosuppressed_admission +
                          Vaccination_statusonly_CoV2 +
                          SeverityCoV2_or_Flu_int + 
                          Sex + Age,
                        data=na.omit(data_aPL_regr_plot_PT_IgM), doTrace=2, maxRuns=1000)  # perform Boruta search

boruta_PT_IgM_signif_02 <- names(boruta_PT_IgM_02$finalDecision[boruta_PT_IgM_02$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
print(boruta_PT_IgM_signif_02)  # significant variables

plot(boruta_PT_IgM_02, cex.axis=.5, las=2, xlab="", main="Variable Importance PT IgM >1")  # plot variable importance

# B2GPI_IgM

boruta_ß2GPI_IgM <- Boruta(ß2GPI_IgM ~ PC1_IgG + PC1_IgA +
                          Spike_IgG + RBD_IgG + NC_IgG + 
                          Spike_IgA + RBD_IgA + NC_IgA +
                          GCSF + GMCSF + IFNalpha + IFNgamma + IL1beta + IL4 + IL6 + IL8 + IL10 + IL17A + IP10 + MIP1alpha +
                          MIP1beta + S100A8_A9 + SDF1alpha + TNFalpha + Inflammatory_index +
                          Acute_SARS_CoV_2_infection + 
                          Anticoagulation.at.event + 
                          Platelet.aggregation.inhibitor.at.event +
                          Immunosuppressed_admission +
                          Vaccination_statusonly_CoV2 +
                          SeverityCoV2_or_Flu_int + 
                          Sex + Age,
                        data=na.omit(data_aPL_regr), doTrace=2, maxRuns=1000)  # perform Boruta search

boruta_ß2GPI_IgM_signif <- names(boruta_ß2GPI_IgM$finalDecision[boruta_ß2GPI_IgM$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
print(boruta_ß2GPI_IgM_signif)  # significant variables

plot(boruta_ß2GPI_IgM, cex.axis=.5, las=2, xlab="", main="Variable Importance ß2GPI IgM all")  # plot variable importance

boruta_ß2GPI_IgM_02 <- Boruta(ß2GPI_IgM ~ PC1_IgG + PC1_IgA +
                          Spike_IgG + RBD_IgG + NC_IgG + 
                          Spike_IgA + RBD_IgA + NC_IgA +
                          GCSF + GMCSF + IFNalpha + IFNgamma + IL1beta + IL4 + IL6 + IL8 + IL10 + IL17A + IP10 + MIP1alpha +
                          MIP1beta + S100A8_A9 + SDF1alpha + TNFalpha + Inflammatory_index +
                          Acute_SARS_CoV_2_infection + 
                          Anticoagulation.at.event + 
                          Platelet.aggregation.inhibitor.at.event +
                          Immunosuppressed_admission +
                          Vaccination_statusonly_CoV2 +
                          SeverityCoV2_or_Flu_int + 
                          Sex + Age,
                        data=na.omit(data_aPL_regr_plot_B2GPI_IgM), doTrace=2, maxRuns=1000)  # perform Boruta search

boruta_ß2GPI_IgM_signif_02 <- names(boruta_ß2GPI_IgM_02$finalDecision[boruta_ß2GPI_IgM_02$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
print(boruta_ß2GPI_IgM_signif_02)  # significant variables

plot(boruta_ß2GPI_IgM_02, cex.axis=.5, las=2, xlab="", main="Variable Importance ß2GPI IgM >1")  # plot variable importance

# AnV_IgM

boruta_AnnV_IgM <- Boruta(AnnV_IgM ~ PC1_IgG + PC1_IgA +
                          Spike_IgG + RBD_IgG + NC_IgG + 
                          Spike_IgA + RBD_IgA + NC_IgA +
                          GCSF + GMCSF + IFNalpha + IFNgamma + IL1beta + IL4 + IL6 + IL8 + IL10 + IL17A + IP10 + MIP1alpha +
                          MIP1beta + S100A8_A9 + SDF1alpha + TNFalpha + Inflammatory_index +
                          Acute_SARS_CoV_2_infection + 
                          Anticoagulation.at.event + 
                          Platelet.aggregation.inhibitor.at.event +
                          Immunosuppressed_admission +
                          Vaccination_statusonly_CoV2 +
                          SeverityCoV2_or_Flu_int + 
                          Sex + Age,
                      data=na.omit(data_aPL_regr), doTrace=2, maxRuns=1000)  # perform Boruta search

boruta_AnnV_IgM_signif <- names(boruta_AnnV_IgM$finalDecision[boruta_AnnV_IgM$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
print(boruta_AnnV_IgM_signif)  # significant variables

plot(boruta_AnnV_IgM, cex.axis=.5, las=2, xlab="", main="Variable Importance AnV IgM all")  # plot variable importance

boruta_AnnV_IgM_02 <- Boruta(AnnV_IgM ~ PC1_IgG + PC1_IgA +
                          Spike_IgG + RBD_IgG + NC_IgG + 
                          Spike_IgA + RBD_IgA + NC_IgA +
                          GCSF + GMCSF + IFNalpha + IFNgamma + IL1beta + IL4 + IL6 + IL8 + IL10 + IL17A + IP10 + MIP1alpha +
                          MIP1beta + S100A8_A9 + SDF1alpha + TNFalpha + Inflammatory_index +
                          Acute_SARS_CoV_2_infection + 
                          Anticoagulation.at.event + 
                          Platelet.aggregation.inhibitor.at.event +
                          Immunosuppressed_admission +
                          Vaccination_statusonly_CoV2 +
                          SeverityCoV2_or_Flu_int + 
                          Sex + Age,
                      data=na.omit(data_aPL_regr_plot_AnV_IgM), doTrace=2, maxRuns=1000)  # perform Boruta search

boruta_AnnV_IgM_signif_02 <- names(boruta_AnnV_IgM_02$finalDecision[boruta_AnnV_IgM_02$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
print(boruta_AnnV_IgM_signif_02)  # significant variables

plot(boruta_AnnV_IgM_02, cex.axis=.5, las=2, xlab="", main="Variable Importance AnV IgM >1")  # plot variable importance

# CL_IgG

boruta_CL_IgG <- Boruta(CL_IgG ~ PC1_IgG + PC1_IgA +
                            Spike_IgG + RBD_IgG + NC_IgG + 
                            Spike_IgA + RBD_IgA + NC_IgA +
                            GCSF + GMCSF + IFNalpha + IFNgamma + IL1beta + IL4 + IL6 + IL8 + IL10 + IL17A + IP10 + MIP1alpha +
                            MIP1beta + S100A8_A9 + SDF1alpha + TNFalpha + Inflammatory_index +
                            Acute_SARS_CoV_2_infection + 
                            Anticoagulation.at.event + 
                            Platelet.aggregation.inhibitor.at.event +
                            Immunosuppressed_admission +
                            Vaccination_statusonly_CoV2 +
                            SeverityCoV2_or_Flu_int + 
                            Sex + Age,
                          data=na.omit(data_aPL_regr), doTrace=2, maxRuns=1000)  # perform Boruta search

boruta_CL_IgG_signif <- names(boruta_CL_IgG$finalDecision[boruta_CL_IgG$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
print(boruta_CL_IgG_signif)  # significant variables

plot(boruta_CL_IgG, cex.axis=.5, las=2, xlab="", main="Variable Importance CL IgG all")  # plot variable importance

boruta_CL_IgG_02 <- Boruta(CL_IgG ~ PC1_IgG + PC1_IgA +
                               Spike_IgG + RBD_IgG + NC_IgG + 
                               Spike_IgA + RBD_IgA + NC_IgA +
                               GCSF + GMCSF + IFNalpha + IFNgamma + IL1beta + IL4 + IL6 + IL8 + IL10 + IL17A + IP10 + MIP1alpha +
                               MIP1beta + S100A8_A9 + SDF1alpha + TNFalpha + Inflammatory_index +
                               Acute_SARS_CoV_2_infection + 
                               Anticoagulation.at.event + 
                               Platelet.aggregation.inhibitor.at.event +
                               Immunosuppressed_admission +
                               Vaccination_statusonly_CoV2 +
                               SeverityCoV2_or_Flu_int + 
                               Sex + Age,
                             data=na.omit(data_aPL_regr_plot_CL_IgG), doTrace=2, maxRuns=1000)  # perform Boruta search

boruta_CL_IgG_signif_02 <- names(boruta_CL_IgG_02$finalDecision[boruta_CL_IgG_02$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
print(boruta_CL_IgG_signif_02)  # significant variables

plot(boruta_CL_IgG_02, cex.axis=.5, las=2, xlab="", main="Variable Importance CL IgG >1")  # plot variable importance
```

Conclusions:

*Overall, we observe that mostly antibodies against SARS-CoV-2 are associated, with disease severity, acute infection, age, and some cytokines, particularly TNF alpha, being modulators.* The link between aPL and TNF alpha has been described before:

- https://link.springer.com/article/10.1007/s00296-009-1314-8
- https://www.sciencedirect.com/science/article/pii/S1043466611001426

### We build a model and assess it for its predictive value

1.  We build models incorporating most of the features found important, both for all values as well as for those only including patients with respective values \> 1;
2.  We run a stepAIC to simplify the model to include the most important parameters;
3.  We compare model predictions with original outcomes.
4.  For this model, we use the dataset where datapoints \<1 are removed. Importantly, we seek to find associations with respective aPL levels, not with absence of levels.

```{r MODEL ASSESSMENTS FOR PREDICTION, message=FALSE, warning=FALSE, fig.height = 10, fig.width = 10}
# For the aPL, we remove data points <1; hence, we try to model associations WITH aPL levels!

# PT model

PT_IgM_model1 <- glm(PT_IgM ~ NC_IgG + PC1_IgG +
                       SeverityCoV2_or_Flu_int +
                       Vaccination_statusonly_CoV2 + Acute_SARS_CoV_2_infection +
                       TNFalpha + S100A8_A9 + IP10 + IL8 + Age + MIP1alpha + Spike_IgA + RBD_IgG,
                     data = data_aPL_regr_plot_PT_IgM, 
                     family = gaussian(link = 'identity'))

PT_IgM_model1_AIC <- stepAIC(PT_IgM_model1, trace=TRUE)

# B2GPI model

ß2GPI_IgM_model1 <- glm(ß2GPI_IgM ~ NC_IgG +
                          NC_IgA + RBD_IgA +
                          SeverityCoV2_or_Flu_int +
                          Vaccination_statusonly_CoV2 +
                          Age +
                          IL4 + TNFalpha + SDF1alpha + IL17A + Age + MIP1alpha + PC1_IgG,
                        data = data_aPL_regr_plot_B2GPI_IgM, 
                        family = gaussian(link = 'identity'))

ß2GPI_IgM_model1_AIC <- stepAIC(ß2GPI_IgM_model1, trace=TRUE)

#AnV model

AnV_IgM_model1 <- glm(AnnV_IgM ~ NC_IgG + PC1_IgG +
                        RBD_IgA + PC1_IgA +
                        SeverityCoV2_or_Flu_int +
                        Acute_SARS_CoV_2_infection +
                        Age +
                        TNFalpha + IL17A + Vaccination_statusonly_CoV2 + IL4,
                      data = data_aPL_regr_plot_AnV_IgM, 
                      family = gaussian(link = 'identity'))

AnV_IgM_model1_AIC <- stepAIC(AnV_IgM_model1, trace=TRUE)

#CL model

CL_IgG_model1 <- glm(CL_IgG ~ NC_IgG + Spike_IgG + PC1_IgG +
                        RBD_IgA + Spike_IgA + PC1_IgA +
                        IL8 + IL4 + MIP1alpha + SDF1alpha +
                        Age,
                      data = data_aPL_regr_plot_CL_IgG, 
                      family = gaussian(link = 'identity'))

CL_IgG_model1_AIC <- stepAIC(CL_IgG_model1, trace=TRUE)



# Data follow-up

prob_PT_IgM_model1 <- PT_IgM_model1 %>% predict(data_aPL_regr_plot_PT_IgM, type = "response")
prob_PT_IgM_model1_AIC <- PT_IgM_model1_AIC %>% predict(data_aPL_regr_plot_PT_IgM, type = "response")
prob_ß2GPI_IgM_model1 <- ß2GPI_IgM_model1 %>% predict(data_aPL_regr_plot_B2GPI_IgM, type = "response")
prob_ß2GPI_IgM_model1_AIC <- ß2GPI_IgM_model1_AIC %>% predict(data_aPL_regr_plot_B2GPI_IgM, type = "response")
prob_AnV_IgM_model1 <- AnV_IgM_model1 %>% predict(data_aPL_regr_plot_AnV_IgM, type = "response")
prob_AnV_IgM_model1_AIC <- AnV_IgM_model1_AIC %>% predict(data_aPL_regr_plot_AnV_IgM, type = "response")
prob_CL_IgG_model1 <- CL_IgG_model1 %>% predict(data_aPL_regr_plot_CL_IgG, type = "response")
prob_CL_IgG_model1_AIC <- CL_IgG_model1_AIC %>% predict(data_aPL_regr_plot_CL_IgG, type = "response")

data_aPL_regr_plot_PT_IgM$PT_IgM_model1_predicted_prob <- as.numeric(prob_PT_IgM_model1)
data_aPL_regr_plot_PT_IgM$PT_IgM_model1_AIC_predicted_prob <- as.numeric(prob_PT_IgM_model1_AIC)
data_aPL_regr_plot_B2GPI_IgM$ß2GPI_IgM_model1_predicted_prob <- as.numeric(prob_ß2GPI_IgM_model1)
data_aPL_regr_plot_B2GPI_IgM$ß2GPI_IgM_model1_AIC_predicted_prob <- as.numeric(prob_ß2GPI_IgM_model1_AIC)
data_aPL_regr_plot_AnV_IgM$AnV_IgM_model1_predicted_prob <- as.numeric(prob_AnV_IgM_model1)
data_aPL_regr_plot_AnV_IgM$AnV_IgM_model1_AIC_predicted_prob <- as.numeric(prob_AnV_IgM_model1_AIC)
data_aPL_regr_plot_CL_IgG$CL_IgG_model1_predicted_prob <- as.numeric(prob_CL_IgG_model1)
data_aPL_regr_plot_CL_IgG$CL_IgG_model1_AIC_predicted_prob <- as.numeric(prob_CL_IgG_model1_AIC)

# Combine

data_aPL_regr_plot_for_plotting_PT <- data_aPL_regr_plot_PT_IgM %>%
  dplyr::select(Unique_sample_ID_for_study, PT_IgM, PT_IgM_model1_predicted_prob, PT_IgM_model1_AIC_predicted_prob) %>%
  dplyr::mutate(Model='A.PT') %>%
  dplyr::rename(Original_value = PT_IgM) %>%
  dplyr::rename(Predicted_value = PT_IgM_model1_predicted_prob) %>%
  dplyr::rename(Predicted_value_AIC = PT_IgM_model1_AIC_predicted_prob)

data_aPL_regr_plot_for_plotting_ß2GPI <- data_aPL_regr_plot_B2GPI_IgM %>%
  dplyr::select(Unique_sample_ID_for_study, ß2GPI_IgM, ß2GPI_IgM_model1_predicted_prob, ß2GPI_IgM_model1_AIC_predicted_prob) %>%
  dplyr::mutate(Model='B.ß2GPI') %>%
  dplyr::rename(Original_value = ß2GPI_IgM) %>%
  dplyr::rename(Predicted_value = ß2GPI_IgM_model1_predicted_prob) %>%
  dplyr::rename(Predicted_value_AIC = ß2GPI_IgM_model1_AIC_predicted_prob)

data_aPL_regr_plot_for_plotting_AnV <- data_aPL_regr_plot_AnV_IgM %>%
  dplyr::select(Unique_sample_ID_for_study, AnnV_IgM, AnV_IgM_model1_predicted_prob, AnV_IgM_model1_AIC_predicted_prob) %>%
  dplyr::mutate(Model='C.AnV') %>%
  dplyr::rename(Original_value = AnnV_IgM) %>%
  dplyr::rename(Predicted_value = AnV_IgM_model1_predicted_prob) %>%
  dplyr::rename(Predicted_value_AIC = AnV_IgM_model1_AIC_predicted_prob)

data_aPL_regr_plot_for_plotting_CL <- data_aPL_regr_plot_CL_IgG %>%
  dplyr::select(Unique_sample_ID_for_study, CL_IgG, CL_IgG_model1_predicted_prob, CL_IgG_model1_AIC_predicted_prob) %>%
  dplyr::mutate(Model='D.CL') %>%
  dplyr::rename(Original_value = CL_IgG) %>%
  dplyr::rename(Predicted_value = CL_IgG_model1_predicted_prob) %>%
  dplyr::rename(Predicted_value_AIC = CL_IgG_model1_AIC_predicted_prob)

data_aPL_regr_plot_for_plotting <- data_aPL_regr %>%
  dplyr::select(Unique_sample_ID_for_study)

data_aPL_regr_plot_for_plotting = bind_rows(data_aPL_regr_plot_for_plotting_PT,
                                            data_aPL_regr_plot_for_plotting_ß2GPI,
                                            data_aPL_regr_plot_for_plotting_AnV,
                                            data_aPL_regr_plot_for_plotting_CL)
obs_vs_pred01 <-
ggplot(data = data_aPL_regr_plot_for_plotting, aes(x = Predicted_value, y = Original_value, color=Model)) +
  geom_pointrange(aes(ymin = Original_value, ymax = Original_value, xmin=Original_value, xmax=Original_value)) +
  geom_smooth(method = "glm", 
              method.args = list(family = gaussian()), colour='blue') +
  stat_smooth(method = "glm", 
              method.args = list(family = gaussian()), colour='blue', lty='dotted', geom='ribbon', fill=NA) +
  stat_cor(method='spearman') +
  geom_abline(slope = 1, intercept = 0, color="red", linetype='dashed') +
  facet_wrap(~Model,ncol=4) +
  theme(axis.text.y = element_text(size = 8)) +
  theme(legend.position="none") +
  labs(y="Observed aPL level",x="Predicted aPL level",title="Observed versus predicted aPL level for models")

obs_vs_pred02 <-
ggplot(data = data_aPL_regr_plot_for_plotting, aes(x = Predicted_value_AIC, y = Original_value, color=Model)) +
  geom_pointrange(aes(ymin = Original_value, ymax = Original_value, xmin=Original_value, xmax=Original_value)) +
  geom_smooth(method = "glm", 
              method.args = list(family = gaussian()), colour='blue') +
  stat_smooth(method = "glm", 
              method.args = list(family = gaussian()), colour='blue', lty='dotted', geom='ribbon', fill=NA) +
  stat_cor(method='spearman') +
  geom_abline(slope = 1, intercept = 0, color="red", linetype='dashed') +
  facet_wrap(~Model,ncol=4) +
  theme(axis.text.y = element_text(size = 8)) +
  theme(legend.position="none") +
  labs(y="Observed aPL level",x="Predicted aPL level",title="Observed versus predicted aPL level for AIC improved models")

```

To ensure the validity of the approach, and, particularly, the plotting, we double check the assumptions using a slightly different way of obtaining the visualisation.

```{r MODEL ASSESSMENTS FOR PREDICTION QUALITY CHECK 1, message=FALSE, warning=FALSE, fig.height = 10, fig.width = 10}

ggscatter(data=data_aPL_regr_plot_for_plotting, 
  x = "Predicted_value", 
  y = "Original_value",
  color = "Model", 
  #palette = "jco",
  add = "reg.line",
  cor.method = 'spearman'
) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_cor(aes(color = Model),method='spearman') +
  labs(y="Original aPL level",x="Predicted aPL level",title="Original versus predicted aPL level for models") +
  theme_classic()

ggscatter(data=data_aPL_regr_plot_for_plotting, 
  x = "Predicted_value_AIC", 
  y = "Original_value",
  color = "Model", 
  #palette = "jco",
  add = "reg.line",
  cor.method = 'spearman'
) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_cor(aes(color = Model),method='spearman') +
  labs(y="Observed aPL level",x="Predicted aPL level",title="Observed versus predicted aPL level for AIC improved models") +
  theme_classic()

```

Observations:

-   The R and p-values obtained are perfectly matched.
-   As seen before,the regression lines necessarily go through the origin and have a slope of 1.
    -   This is expected as the slopes and intercept of the observed values are, by definition, the same as the slopes and intercept of the predicted values, based on the observed values.
    -   The new slopes and intercept are therefore normalised to b0=0 and slope=1.
    -   However, this observation only holds true as long as we plot ALL values with which the initial model was built.
    -   We thank Georg Meisl for verifying this assumption.

Additionally, we generate a non-informative model to visualise how the prediction then looks.

```{r MODEL ASSESSMENTS FOR PREDICTION QUALITY CHECK 2 (non-informative model), message=FALSE, warning=FALSE, fig.height = 10, fig.width = 10}

# PT model non-informative

PT_IgM_model_noninform <- glm(PT_IgM ~ Immunosuppressed_admission,
                     data = data_aPL_regr_plot_PT_IgM, 
                     family = gaussian(link = 'identity'))

# PT model age only
PT_IgM_model_age <- glm(PT_IgM ~ Age,
                     data = data_aPL_regr_plot_PT_IgM, 
                     family = gaussian(link = 'identity'))

# PT model sex only
PT_IgM_model_sex <- glm(PT_IgM ~ Sex,
                     data = data_aPL_regr_plot_PT_IgM, 
                     family = gaussian(link = 'identity'))


prob_PT_IgM_model_noninform <- PT_IgM_model_noninform %>% predict(data_aPL_regr_plot_PT_IgM, type = "response")
prob_PT_IgM_model_age <- PT_IgM_model_age %>% predict(data_aPL_regr_plot_PT_IgM, type = "response")
prob_PT_IgM_model_sex <- PT_IgM_model_sex %>% predict(data_aPL_regr_plot_PT_IgM, type = "response")


data_aPL_regr_plot_PT_IgM$PT_IgM_model1_predicted_prob_noninform <- as.numeric(prob_PT_IgM_model_noninform)
data_aPL_regr_plot_PT_IgM$PT_IgM_model1_predicted_prob_age <- as.numeric(prob_PT_IgM_model_age)
data_aPL_regr_plot_PT_IgM$PT_IgM_model1_predicted_prob_sex <- as.numeric(prob_PT_IgM_model_sex)

data_aPL_regr_plot_noninform_QC <- data_aPL_regr_plot_PT_IgM %>%
  dplyr::select(Unique_sample_ID_for_study, PT_IgM, PT_IgM_model1_predicted_prob_noninform) %>%
  dplyr::mutate(Model='A.Noninform') %>%
  dplyr::rename(Original_value = PT_IgM) %>%
  dplyr::rename(Predicted_value = PT_IgM_model1_predicted_prob_noninform)


data_aPL_regr_plot_age_QC <- data_aPL_regr_plot_PT_IgM %>%
  dplyr::select(Unique_sample_ID_for_study, PT_IgM, PT_IgM_model1_predicted_prob_age) %>%
  dplyr::mutate(Model='B.Age only') %>%
  dplyr::rename(Original_value = PT_IgM) %>%
  dplyr::rename(Predicted_value = PT_IgM_model1_predicted_prob_age)

data_aPL_regr_plot_diff_model_QC <- data_aPL_regr_plot_PT_IgM %>% #Here, we use the sample-matched IgA data, i.e. the data being used is not the one on which the regression had been performed. Hence, we expect both the slopes and the intercepts to differ among each other.
  dplyr::select(Unique_sample_ID_for_study, PT_IgA, PT_IgM_model1_predicted_prob_noninform) %>%
  dplyr::mutate(Model='C.Age only, PT IgA') %>%
  dplyr::rename(Original_value = PT_IgA) %>%
  dplyr::rename(Predicted_value = PT_IgM_model1_predicted_prob_noninform)

data_aPL_regr_plot_sex_QC <- data_aPL_regr_plot_PT_IgM %>%
  dplyr::select(Unique_sample_ID_for_study, PT_IgM, PT_IgM_model1_predicted_prob_sex) %>%
  dplyr::mutate(Model='D.Sex only') %>%
  dplyr::rename(Original_value = PT_IgM) %>%
  dplyr::rename(Predicted_value = PT_IgM_model1_predicted_prob_sex)

data_aPL_regr_plot_QC <- data_aPL_regr %>%
  dplyr::select(Unique_sample_ID_for_study)

data_aPL_regr_plot_QC = bind_rows(data_aPL_regr_plot_noninform_QC,
                                            data_aPL_regr_plot_age_QC, data_aPL_regr_plot_diff_model_QC,data_aPL_regr_plot_sex_QC)

obs_vs_pred03 <-
ggplot(data = data_aPL_regr_plot_QC, aes(x = Predicted_value, y = Original_value, color=Model)) +
  geom_pointrange(aes(ymin = Original_value, ymax = Original_value, xmin=Original_value, xmax=Original_value)) +
  geom_smooth(method = "glm", 
              method.args = list(family = gaussian()), colour='blue') +
  stat_smooth(method = "glm", 
              method.args = list(family = gaussian()), colour='blue', lty='dotted', geom='ribbon', fill=NA) +
  stat_cor(method='spearman') +
  geom_abline(slope = 1, intercept = 0, color="red", linetype='dashed') +
  facet_wrap(~Model,ncol=4) +
  theme(axis.text.y = element_text(size = 8)) +
  theme(legend.position="none") +
  labs(y="Observed aPL level",x="Predicted aPL level",title="Observed versus predicted aPL level for non-informative models")

ggarrange(obs_vs_pred01, obs_vs_pred02, obs_vs_pred03,
          labels = c("A", "B", 'C'),
          ncol = 1, nrow = 3)

```

Observations:

-   The models are unsuited to predict the observed aPL values, both
    -   the uninformative (where, in regression, only 'immunosuppressed at admission' was chosen) model as well as
    -   the model that includes only age.
-   The choice of parameters for modelling are thus important to obtain a model of valid predictive character.

Overall, we conclude that while not in general, aPL levels for PT IgM, B2GPI IgM, AnV IgM, and CL IgG are modulated by the strength of the antibody response against SARS-CoV-2 and further modulated by other factors, including age. These observations validate findings reported previously.

# SEROCONVERSION {.tabset .tabset-fade .tabset-pills}

In our previous study, we have shown the presence of IgM aPL titres but titres for IgG were low and did not display a change between infected and non-infected individuals. To increase the scrutiny of these reports, we have undertaken the effort to characterise seroconversion, in IgM, IgG, and IgA aPL. We use multiple approaches to investigate the phenomenon.

## We compare IgG, IgM, and IgA of the same individuals, time-point-matched

We group together all IgG, IgM, IgA measurements

```{r SEROCONVERSION ALL GROUPS STATS, fig.height = 10, fig.width = 10}
compare_means(aPL_signal ~ Isotype,  data=subset(data_vertical, CoV2_type == 'Spike_IgG'),
              method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH")
```

Observations:

-   We observe that mean IgM values are generally higher than mean IgG or IgA.
-   We observe that mean IgA values are generally higher than mean IgG.
-   All distributions are significantly different.

```{r SEROCONVERSION ALL GROUPS, fig.height = 10, fig.width = 10}
seroconv01 <-
subset(data_vertical, CoV2_type == 'Spike_IgG') %>%
  dplyr::arrange(Isotype) %>%
  ggboxplot(x = "Isotype", y = "aPL_signal",
    color = "Isotype", palette = c(col4), outlier.shape = NA, add = "mean",
    merge = TRUE
  ) +
    geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = Isotype)) +
    geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
    stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
                 aes(group = Isotype), color = "darkred",
                 position = position_dodge(width = 0.8)) +
    stat_summary(fun = mean, colour = "red", 
                 position = position_dodge(width = 0.8),
                 geom = "text", vjust = -0.7, 
                 aes(label = round(..y.., digits = 1), group = Isotype)) +
    guides(x =  guide_axis(angle = 90)) +
    theme_classic()

```

## We correlate the three isotypes against each other

```{r SEROCONVERSION IgG versus IgM, fig.height = 10, fig.width = 10}
ggscatter(
  data=subset(data_vertical, CoV2_type == 'Spike_IgG' | Isotype == 'IgG'), 
  x = "aPL_signal_IgG",
  y = "aPL_signal_IgM",
  palette = "jco",
  add = "reg.line",
  cor.method = 'spearman'
  ) +
  stat_cor(method='spearman') +
  theme_classic()
```

We notice that there is hardly any correlation.

```{r SEROCONVERSION IgG versus IgA, fig.height = 10, fig.width = 10}
ggscatter(
  data=subset(data_vertical, CoV2_type == 'Spike_IgG' | Isotype == 'IgG'), 
  x = "aPL_signal_IgG",
  y = "aPL_signal_IgA",
  palette = "jco",
  add = "reg.line",
  cor.method = 'spearman'
) +
  stat_cor(method='spearman') +
  theme_classic()
```

We notice that there is hardly any correlation but slightly more than when IgM is involved.

```{r SEROCONVERSION IgA versus IgM, fig.height = 10, fig.width = 10}
ggscatter(
  data=subset(data_vertical, CoV2_type == 'Spike_IgG' | Isotype == 'IgG'), 
  x = "aPL_signal_IgM",
  y = "aPL_signal_IgA",
  palette = "jco",
  add = "reg.line",
  cor.method = 'spearman'
) +
  stat_cor(method='spearman') +
  theme_classic()
```

We notice that there is hardly any correlation.

## We plot the DPO with colour-coded IgG, IgA, and IgM

```{r SEROCONVERSION DPO ALL ISOTYPES, fig.height = 10, fig.width = 10}
seroconv02 <-
   ggplot(data=subset(data_vertical, CoV2_type == 'Spike_IgG'), aes(x = DPOCoV2_or_FLU, y = aPL_signal, color=Isotype)) +
  geom_point() +
  geom_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype)) +
  stat_smooth(method = "glm", 
              method.args = list(family = gaussian()), aes(colour=Isotype), lty='dotted', geom='ribbon', fill=NA) +
  stat_cor(method='spearman') +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  scale_fill_manual(values=c(col4)) +
  scale_color_manual(values=c(col4)) +
  theme(axis.text.y = element_text(size = 8)) +
  labs(y="aPL signal",x="DPO",title="")
  
```

Observations:

-   When observing the behaviour of levels based on DPO, i.e. restricting the analysis on individuals that had been infected and thus have a DPO, we see that there is hardly any trend, and clearly not a linear trend. Neither for IgM, nor for IgG or IgA.
-   Importantly, there is no evidence for seroconversion on the global scale.

#### 5.4. We plot the DPO for previous and new data (i.e. we compare the two datasets) with colour-coded datasets and shapes for IgG, IgA, and IgM

```{r SEROCONVERSION DPO ALL ISOTYPES COMPARISON, fig.height = 10, fig.width = 10}
ggscatter(
  data=subset(published_data_comparison,
              Isotype == 'IgG' | 
              Isotype == 'IgM' |
              Isotype == 'IgA'), 
  x = "DPOCoV2_or_FLU", 
  y = "aPL_signal",
  color = "dataset", 
  palette = "npg",
  cor.method = 'spearman'
  ) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  facet_wrap(~Isotype,ncol=3) +
  theme_classic()
```

Observations: 

- As seen before, we cover a larger range of DPO in the new dataset.
- Also, as seen before, the old dataset had some 'higher' values, in general.
- Overall, the distributions are comparable.

#### 5.5. We look at different timepoints of the same individuals

```{r SEROCONVERSION COMPARING TWO ESTIMATES STATS, fig.height = 10, fig.width = 10}
##### We compare the two timepoints for IgG and IgM
compare_means(aPL_signal ~ Timepoint,  data=subset(data_vertical, CoV2_type == 'Spike_IgG'),
              method = "wilcox", group.by = 'Isotype', symnum.args=signifiance_stars, p.adjust.method = "BH")
```

Observations:

-   Globally, IgM values tend to increase at the second time point, but not IgG.
-   IgA follows the trend of IgM.

```{r SEROCONVERSION COMPARING TWO ESTIMATES, fig.height = 10, fig.width = 10}

seroconv03 <-
  subset(data_vertical, CoV2_type == 'Spike_IgG') %>%
  dplyr::arrange(Isotype) %>%
  ggplot(aes(x = Isotype, y = aPL_signal)) +
    geom_boxplot(aes(color = as.factor(Timepoint)), outlier.shape = NA, add = "mean") +
    geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = as.factor(Timepoint))) +
    geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
    stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
                 aes(group = interaction(Isotype, Timepoint)), color = "darkred",
                 position = position_dodge(width = 0.8)) +
    stat_summary(fun = mean, colour = "red", 
                 position = position_dodge(width = 0.8),
                 geom = "text", vjust = -0.7, 
                 aes(label = round(..y.., digits = 1), group = interaction(Isotype, Timepoint))) +
    scale_color_manual(values=c('black', 'darkgrey')) +
    theme_classic()

```

## We look at the distance between the two measurements, where available

We use a natural spline to model the behaviour of the DPO over time, individually for IgM, IgG, and IgA. See here 

- https://stats.stackexchange.com/questions/517375/splines-relationship-of-knots-degree-and-degrees-of-freedom
- https://stats.stackexchange.com/questions/7316/setting-knots-in-natural-cubic-splines-in-r
- https://towardsdatascience.com/numerical-interpolation-natural-cubic-spline-52c1157b98ac
- For a nice overview on splines in action, see Gauthier et al. (2019): https://doi.org/10.1038/s41409-019-0679-x
- Also, consider Perperoglou et al. (2019): https://doi.org/10.1186/s12874-019-0666-3

for what some of the parameters of the spline mean. We hope that the spline if the trend was nonlinear, e.g., would indicate such a behaviour. If the spline appears largely monotonous and linear, we will interpret it as such and in this case, we will observe the slope. If,then, there is an indication that the slope should be considered more closely, we will use a proper linear model to perform a linear regression on the data.

```{r SEROCONVERSION COMPARING TWO ESTIMATES DPO DISTANCE, fig.height = 10, fig.width = 10}

# We assess the percentiles in the data per isotype
data_vertical_tp %>%
  group_by(Isotype) %>%
  summarise(percent10 = quantile(Time_diff, probs = .1),
            percent25 = quantile(Time_diff, probs = .25),
            percent50 = quantile(Time_diff, probs = .5),
            percent75 = quantile(Time_diff, probs = .75),
            percent90 = quantile(Time_diff, probs = .9))

# We assess the percentiles in the data regardless of isotype - they are all the same
data_vertical_tp %>%
  summarise(percent10 = quantile(Time_diff, probs = .1),
            percent25 = quantile(Time_diff, probs = .25),
            percent50 = quantile(Time_diff, probs = .5),
            percent75 = quantile(Time_diff, probs = .75),
            percent90 = quantile(Time_diff, probs = .9))

# Comment: the data is obviously highly shifted towards 0. For the spline, to give it flexibility, we set a knot at the 90th percentile, which, looking at the data, is justified.

# We fit the spline and plot the data

seroconv04 <-
ggscatter(
  data=data_vertical_tp, 
  x = "Time_diff", 
  y = "aPL_signal",
  shape = 'Isotype',
  cor.method = 'spearman'
) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  geom_line(aes(group = interaction(Unique_patient_ID, aPL_type), color=interaction(Unique_patient_ID, aPL_type)), linetype='dashed') +
  geom_smooth(method ='lm', formula = y ~ splines::ns(x, knots=c(10), # We define an interior knot at the 90th percentile. 
                                                      Boundary.knots = range(x)), #= c(0,50)), i.e. We could set the boundary knots at the actual boundary...
              aes(fill=Isotype)) +
  theme_classic() +
  theme(legend.position="none")
seroconv04

ggarrange(seroconv01, seroconv02, seroconv03, seroconv04,
          labels = c("A", "B", 'C','D'),
          ncol = 2, nrow = 2)

```

Here we look at matched patient samples with more than one timepoints. The dashed lines connect patients for a given aPL (e.g. PI) and isotype (e.g. IgA), i.e. PI_IgA, or PI_IgG, or PI_IgM, etc.

-   square, red spline: IgM
-   round. blue spline: IgA
-   triangle, green spline: IgG

Observations:

-   We cannot identify a trend towards higher values with increased DPO...
-   Overall, we do not see a trend for IgG seroconversion.
-   The titres seem remarkably stable over time.
-   The near-linear behaviour of the splines indicates that overall, the titres remained similar over time. If anything, after a small increase, the splines (IgA and IgM) decrease again with later time points. The regression on IgG is behaving as a flat line.

Conclusions:

*Both when looking at all data together, or when looking at matched time points, there is no indication for seroconversion in the given dataset. On the contrary, IgM, IgG, and IgA aPL appear stable over time.*

# COMPARISON OF SARS-COV-2 INFECTED WITH VACCINATED AND WITH INFLUENZA {.tabset .tabset-fade .tabset-pills}

-   If we compare the aPL levels in SARS-CoV-2 infected individuals to another disease, here influenza, does it look generic or specific to SARS-CoV-2?
-   Is it infection with SARS-CoV-2 that elicits higher levels of aPL IgM, or equally so vaccination with mRNA vaccine?

## We look at it in a generic manner - we compare all aPL together

```{r COMPARISON WITH VACCINE OR INFLUENZA generic stat, fig.height = 10, fig.width = 10}
### We conduct the statistics and save tables

# IgM

aPL_IgM_stats_together <-
compare_means(aPL_signal_IgM ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG' & Isotype == 'IgM'), method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH", ref.group = '01_Non-infected/non-vaccinated') %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# IgG
aPL_IgG_stats_together <-
compare_means(aPL_signal_IgG ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG' & Isotype == 'IgG'), method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH", ref.group = '01_Non-infected/non-vaccinated') %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# IgA
aPL_IgA_stats_together <-
compare_means(aPL_signal_IgA ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG' & Isotype == 'IgA'), method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH", ref.group = '01_Non-infected/non-vaccinated') %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

###  We calculate the fold change from baseline (non-infected/non-vaccinated), for all isotypes separately

# IgM

data_vertical_summary_IgM_map <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgM') %>%
  dplyr::filter(COVID_vaccination_Group=='01_Non-infected/non-vaccinated') %>%
  dplyr::group_by(COVID_vaccination_Group) %>%
  dplyr::summarise(Median_baseline=median(aPL_signal_IgM),na.rm = TRUE) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP')

data_vertical_summary_IgM <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgM') %>%
  dplyr::group_by(COVID_vaccination_Group) %>%
  dplyr::summarise(Mean=mean(aPL_signal_IgM), Max=max(aPL_signal_IgM), Min=min(aPL_signal_IgM), Median=median(aPL_signal_IgM), Std=sd(aPL_signal_IgM),Q1=quantile(aPL_signal_IgM, probs = 0.25), Q3=quantile(aPL_signal_IgM, probs = 0.75),na.rm = TRUE) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP') %>%
  dplyr::left_join(data_vertical_summary_IgM_map, by = 'MAP') %>%
  dplyr::mutate(Median_change = round(Median/Median_baseline,2))

# IgG

data_vertical_summary_IgG_map <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgG') %>%
  dplyr::filter(COVID_vaccination_Group=='01_Non-infected/non-vaccinated') %>%
  dplyr::group_by(COVID_vaccination_Group) %>%
  dplyr::summarise(Median_baseline=median(aPL_signal_IgG),na.rm = TRUE) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP')

data_vertical_summary_IgG <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgG') %>%
  dplyr::group_by(COVID_vaccination_Group) %>%
  dplyr::summarise(Mean=mean(aPL_signal_IgG), Max=max(aPL_signal_IgG), Min=min(aPL_signal_IgG), Median=median(aPL_signal_IgG), Std=sd(aPL_signal_IgG),Q1=quantile(aPL_signal_IgG, probs = 0.25), Q3=quantile(aPL_signal_IgG, probs = 0.75),na.rm = TRUE) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP') %>%
  dplyr::left_join(data_vertical_summary_IgG_map, by = 'MAP') %>%
  dplyr::mutate(Median_change = round(Median/Median_baseline,2))

# IgA

data_vertical_summary_IgA_map <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgA') %>%
  dplyr::filter(COVID_vaccination_Group=='01_Non-infected/non-vaccinated') %>%
  dplyr::filter(!is.na(as.numeric(aPL_signal))) %>%
  dplyr::group_by(COVID_vaccination_Group) %>%
  dplyr::summarise(Median_baseline=median(aPL_signal_IgA),na.rm = TRUE) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP')

data_vertical_summary_IgA <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgA') %>%
  dplyr::group_by(COVID_vaccination_Group) %>%
  dplyr::filter(!is.na(as.numeric(aPL_signal))) %>%
  dplyr::summarise(Mean=mean(aPL_signal_IgA), Max=max(aPL_signal_IgA), Min=min(aPL_signal_IgA), Median=median(aPL_signal_IgA), Std=sd(aPL_signal_IgA),Q1=quantile(aPL_signal_IgA, probs = 0.25), Q3=quantile(aPL_signal_IgA, probs = 0.75),na.rm = TRUE) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP') %>%
  dplyr::left_join(data_vertical_summary_IgA_map, by = 'MAP') %>%
  dplyr::mutate(Median_change = round(Median/Median_baseline,2))

```

```{r COMPARISON WITH VACCINE OR INFLUENZA generic, fig.height = 10, fig.width = 10}

subset(data_vertical,CoV2_type == 'Spike_IgG') %>%
  dplyr::arrange(COVID_vaccination_Group) %>%
  ggboxplot(x = "COVID_vaccination_Group", y = "aPL_signal",
    color = "COVID_vaccination_Group", palette = "jco", outlier.shape = NA, add = "mean",
    merge = TRUE
  ) +
    geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
    geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
    stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
                 aes(group = COVID_vaccination_Group), color = "darkred",
                 position = position_dodge(width = 0.8)) +
    stat_summary(fun = mean, colour = "red", 
                 position = position_dodge(width = 0.8),
                 geom = "text", vjust = -0.7, 
                 aes(label = round(..y.., digits = 1), group = COVID_vaccination_Group)) +
    guides(x =  guide_axis(angle = 90)) +
    facet_wrap(~Isotype,ncol=3) +
    theme(axis.text.y = element_text(size = 8)) +
    labs(y="aPL level",x="Inf, vacc, infl",title="Infected versus vaccianted versus influenza")

```

## We do it for all individually

```{r COMPARISON WITH VACCINE OR INFLUENZA FOR all specific stat, fig.height = 10, fig.width = 10}
### We conduct the statistics and save tables

# IgM
aPL_IgM_stats <-
compare_means(aPL_signal_IgM ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG' & Isotype == 'IgM'), method = "wilcox", group.by = "Target", symnum.args=signifiance_stars, p.adjust.method = "BH", ref.group = '01_Non-infected/non-vaccinated') %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# IgG
aPL_IgG_stats <-
compare_means(aPL_signal_IgG ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG' & Isotype == 'IgG'), method = "wilcox", group.by = "Target", symnum.args=signifiance_stars, p.adjust.method = "BH", ref.group = '01_Non-infected/non-vaccinated') %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# IgA
aPL_IgA_stats <-
compare_means(aPL_signal_IgA ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG' & Isotype == 'IgA'), method = "wilcox", group.by = "Target", symnum.args=signifiance_stars, p.adjust.method = "BH", ref.group = '01_Non-infected/non-vaccinated') %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

###  We calculate the fold change from baseline (non-infected/non-vaccinated), for all isotypes and targets separately

# IgM

data_vertical_summary_IgM_map_indiv <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgM') %>%
  dplyr::filter(COVID_vaccination_Group=='01_Non-infected/non-vaccinated') %>%
  dplyr::group_by(COVID_vaccination_Group, Target) %>%
  dplyr::summarise(Median_baseline=median(aPL_signal_IgM)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP')

data_vertical_summary_IgM_indiv <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgM') %>%
  dplyr::group_by(COVID_vaccination_Group, Target) %>%
  dplyr::summarise(Mean=mean(aPL_signal_IgM), Max=max(aPL_signal_IgM), Min=min(aPL_signal_IgM), Median=median(aPL_signal_IgM), Std=sd(aPL_signal_IgM),Q1=quantile(aPL_signal_IgM, probs = 0.25), Q3=quantile(aPL_signal_IgM, probs = 0.75)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP') %>%
  dplyr::left_join(data_vertical_summary_IgM_map_indiv, by = 'Target') %>%
  dplyr::mutate(Median_change = round(Median/Median_baseline,2))

# IgG

data_vertical_summary_IgG_map_indiv <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgG') %>%
  dplyr::filter(COVID_vaccination_Group=='01_Non-infected/non-vaccinated') %>%
  dplyr::group_by(COVID_vaccination_Group, Target) %>%
  dplyr::summarise(Median_baseline=median(aPL_signal_IgG)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP')

data_vertical_summary_IgG_indiv <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgG') %>%
  dplyr::group_by(COVID_vaccination_Group, Target) %>%
  dplyr::summarise(Mean=mean(aPL_signal_IgG), Max=max(aPL_signal_IgG), Min=min(aPL_signal_IgG), Median=median(aPL_signal_IgG), Std=sd(aPL_signal_IgG),Q1=quantile(aPL_signal_IgG, probs = 0.25), Q3=quantile(aPL_signal_IgG, probs = 0.75)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP') %>%
  dplyr::left_join(data_vertical_summary_IgG_map_indiv, by = 'Target') %>%
  dplyr::mutate(Median_change = round(Median/Median_baseline,2))

# IgA

data_vertical_summary_IgA_map_indiv <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgA') %>%
  dplyr::filter(COVID_vaccination_Group=='01_Non-infected/non-vaccinated') %>%
  dplyr::filter(!is.na(as.numeric(aPL_signal))) %>%
  dplyr::group_by(COVID_vaccination_Group, Target) %>%
  dplyr::summarise(Median_baseline=median(aPL_signal_IgA)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP')

data_vertical_summary_IgA_indiv <- data_vertical %>%
  dplyr::filter(CoV2_type == 'Spike_IgG' & Isotype == 'IgA') %>%
  dplyr::filter(!is.na(as.numeric(aPL_signal))) %>%
  dplyr::group_by(COVID_vaccination_Group, Target) %>%
  dplyr::summarise(Mean=mean(aPL_signal_IgA), Max=max(aPL_signal_IgA), Min=min(aPL_signal_IgA), Median=median(aPL_signal_IgA), Std=sd(aPL_signal_IgA),Q1=quantile(aPL_signal_IgA, probs = 0.25), Q3=quantile(aPL_signal_IgA, probs = 0.75)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(MAP = 'MAP') %>%
  dplyr::left_join(data_vertical_summary_IgA_map_indiv, by = 'Target') %>%
  dplyr::mutate(Median_change = round(Median/Median_baseline,2))

```

```{r COMPARISON WITH VACCINE OR INFLUENZA FOR all specific, fig.height = 12, fig.width = 10}

subset(data_vertical,CoV2_type == 'Spike_IgG') %>%
  dplyr::arrange(COVID_vaccination_Group) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("CL"), "A.CL")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PA"), "B.PA")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PC"), "C.PC")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PE"), "D.PE")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PG"), "E.PG")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PL"), "F.PI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PS"), "G.PS")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("AnnV"), "H.AnV")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("ß2GPI"), "I.ß2GPI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PT"), "J.PT")) %>%
  ggboxplot(x = "COVID_vaccination_Group", y = "aPL_signal",
    color = "COVID_vaccination_Group", palette = "jco", outlier.shape = NA, add = "mean",
    merge = TRUE
  ) +
    geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
    geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
    #stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
    #             aes(group = COVID_vaccination_Group), color = "darkred",
    #             position = position_dodge(width = 0.8)) +
    #stat_summary(fun = mean, colour = "red", 
    #             position = position_dodge(width = 0.8),
    #             geom = "text", vjust = -0.7, 
    #             aes(label = round(..y.., digits = 1), group = COVID_vaccination_Group)) +
    guides(x =  guide_axis(angle = 90)) +
    facet_grid(rows=vars(Isotype), cols= vars(Target), scales='free_y', switch='y') +
    theme(axis.text.y = element_text(size = 8)) +
    labs(y="aPL level",x="Inf, vacc, infl",title="Infected versus vaccianted versus influenza")

```

## We do it specifically for PT_IgM, B2GPI_IgM, AnV_IgM

```{r COMPARISON WITH VACCINE OR INFLUENZA specific stat, fig.height = 10, fig.width = 10}
# PT IgM
compare_means(aPL_signal_IgM ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG', aPL_type='PT_IgM'), method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# PT IgG
compare_means(aPL_signal_IgG ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG'),aPL_type='PT_IgG', method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# PT IgA
compare_means(aPL_signal_IgA ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG'), aPL_type='PT_IgA', method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# B2GPI IgM
compare_means(aPL_signal_IgM ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG', aPL_type='ß2GPI_IgM'), method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# B2GPI IgG
compare_means(aPL_signal_IgG ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG'),aPL_type='ß2GPI_IgG', method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# B2GPI IgA
compare_means(aPL_signal_IgA ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG'), aPL_type='ß2GPI_IgA', method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# AnV IgM
compare_means(aPL_signal_IgM ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG', aPL_type='AnnV_IgM'), method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# AnV IgG
compare_means(aPL_signal_IgG ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG'),aPL_type='AnnV_IgG', method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

# AnV IgA
compare_means(aPL_signal_IgA ~ COVID_vaccination_Group,  data=subset(data_vertical, CoV2_type == 'Spike_IgG'), aPL_type='AnnV_IgA', method = "wilcox", symnum.args=signifiance_stars, p.adjust.method = "BH") %>%
  as.data.frame() %>%
  dplyr::arrange(p.adj)

```

```{r COMPARISON WITH VACCINE OR INFLUENZA specific, fig.width=10, fig.height=10}

subset(data_vertical, 
              CoV2_type == 'Spike_IgG' &
              Target == 'PT' | 
              Target == 'ß2GPI' |
              Target == 'AnnV') %>%
  dplyr::arrange(COVID_vaccination_Group) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("AnnV"), "C.AnV")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("ß2GPI"), "B.ß2GPI")) %>%
  dplyr::mutate(Target = str_replace_all(Target, fixed("PT"), "A.PT")) %>%
ggboxplot(x = "COVID_vaccination_Group", y = "aPL_signal",
  color = "COVID_vaccination_Group", palette = "jco", outlier.shape = NA, add = "mean",
  merge = TRUE
) +
  geom_point(shape=16, position=position_jitterdodge(jitter.width = 0.1), aes(color = COVID_vaccination_Group)) +
  geom_hline(yintercept=50, linetype="dashed", color = "red", size=1) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3,
               aes(group = COVID_vaccination_Group), color = "darkred",
               position = position_dodge(width = 0.8)) +
  stat_summary(fun = mean, colour = "red", 
               position = position_dodge(width = 0.8),
               geom = "text", vjust = -0.7, 
               aes(label = round(..y.., digits = 1), group = COVID_vaccination_Group)) +
  guides(x =  guide_axis(angle = 90)) +
  facet_wrap(~interaction(Target, Isotype),ncol=3) +
  theme(axis.text.y = element_text(size = 8)) +
  labs(y="aPL level",x="Inf, vacc, infl",title="Infected versus vaccianted versus influenza PT, B2GPI, and AnV")

```

# THROMBOTIC EVENTS {.tabset .tabset-fade .tabset-pills}

Are thrombotic events linked to the occurrence of aPL? We have not, previously, linked the finding to a clinical phenotype. Thrombotic events have been described in the frame of and have been associated with infection with SARS-CoV-2.

-   There is evidence that the overreacting immune system, as a response to infection, elicits autoantibodies, including antiphospholipid antibodies.
-   The link between antiphospholipid antibodies and thromboses is well established.
-   Others have focused more on cytokines and a state of hyperinflammation, which may predispose to thromboses.
-   Interfering with complement and the coagulation cascade may result in higher chances of thromboses.

*Here, we may have the chance to identify such an association. Mostly, we aim to identify what features - clinical, demographic, or molecular - predict the occurrence of thrombotic events.*

However, it shall be noted that one particular model is unlikely to fully reflect the relationships among the data. We will therefore employ multiple models and report on how they compare with each other, to gain more confidence in the data relation we might discover.

One more important disclaimer: For this analysis, we will omit the patients for which we have NA values (stemming from the cytokine dataset). There is a trade-off between including more/all patients/samples and including more/all features.

## We prepare the data for various regression models

```{r PREPARATION FOR REGRESSION MODELS, fig.height = 10, fig.width = 10}
data_LR <- data_aPL_regr %>% 
  dplyr::select(-Unique_sample_ID_for_study,
                -aPL_IgG_rowmean,
                -aPL_IgA_rowmean,
                -aPL_IgM_rowmean
                ) %>%
  na.omit() #We omit the patients with NA values (in the cytokines) - we do it here to avoid problems further downstream. There is a tradeoff between excluding patients/samples and including parameters... If we excluded the cytokines from these analyses, we could include all patients/samples.

#data_LR$Thrombosis_group = as.factor(data_LR$Thrombosis_group) # If we want to use a binomial model
#data_LR$SeverityCoV2_or_Flu = as.factor(data_LR$SeverityCoV2_or_Flu) #If we wanted to use this as categorical variable
data_LR$Sex = as.factor(data_LR$Sex)

# We scale the numeric data
#data_LR %>% 
#  dplyr::mutate_at(c(2:39,41,47:49), scale)

data_LR_collin <- data_LR %>%  # Removal of some highly collinear features
                dplyr::select(Thrombosis_group,
                CL_IgG:PT_IgA, 
                PC1_IgG, PC1_IgA, NC_IgG, NC_IgA, Spike_IgG, Spike_IgA, # we omit RBD as they are highly collinear with Spike
                Sex, Age,
                SeverityCoV2_or_Flu_int, Acute_SARS_CoV_2_infection,
                Anticoagulation.chronic, # we omit at event
                Platelet.aggregation.inhibitor.at.event,#we omit chronic
                Immunosuppressed_admission, Vaccination_statusonly_CoV2)

data_LR_aPL <- data_LR %>%  # only aPL with age and sex
                dplyr::select(Thrombosis_group,
                CL_IgG:PT_IgA, 
                Sex, Age)

data_LR_CoV2 <- data_LR %>%  # only SARS-COV-2 antibodies with age and sex
                dplyr::select(Thrombosis_group,
                NC_IgG, NC_IgA, Spike_IgG, Spike_IgA, RBD_IgG, RBD_IgA,
                Sex, Age)

data_LR_CK <- data_LR %>%  # only SARS-COV-2 antibodies with age and sex
                dplyr::select(Thrombosis_group,
                GCSF:Inflammatory_index,
                Sex, Age)

sapply(data_LR, class)

```

Notes:

-   DPO is not included as a feature as there are NA values (for individuals who had never had the disease).
-   Boolean: Acute_SARS_CoV_2 infection, Anticoagulation.at.event, Anticoagulation.chronic, Platelet.aggregation.inhibitor.at.event, Platelet.aggregation.inhibitor.chronic,
-   Factors: Sex
-   Numeric: all other entries
-   Outcome: numeric (Bernoulli, 0 and 1); we could factorise them into 'No' and 'Yes' to run the binomial model with logit link function. But the binomial model works just well with 0 and 1, too, if it does at all.

Our output variable is confined to either 0 ('No') or 1 ('Yes') and as such, is representing a Bernoulli distribution, i.e. has binary outcome. The families used in the glm approaches are nicely explained here:

-   <https://stats.stackexchange.com/questions/190763/how-to-decide-which-glm-family-to-use>
-   <https://stats.stackexchange.com/questions/65463/intuition-behind-binomial-logistic-glm>
-   <https://stats.stackexchange.com/questions/245241/difference-between-logistic-regression-and-binomal-glm-with-logistic-link>
-   <https://stats.stackexchange.com/questions/44569/logistic-vs-linear-regression>
-   <https://stats.stackexchange.com/questions/29325/what-is-the-difference-between-linear-regression-and-logistic-regression>
-   <https://stats.stackexchange.com/questions/105301/dependent-variable-coding-for-logistic-regression-in-r>
-   <https://towardsdatascience.com/a-primer-on-generalized-linear-models-ab1769a03100>

In our case, for feature selection, the employment of a conventional glm with logit link function will most likely result in lots of statistical fluctuations, particularly because the large interdependence of the features (see comments on collinear features further below). We will test it out.

We primarily wish to employ binomial (Bernoulli) model with logit link function, i.e. multiple logistic regression. Alternatively, to make the model more robust, we might be using Gaussian family with identity link instead of a binomial with a logit link function. In this sense, we essentially employ an ordinary linear model (see e.g. here: <https://stats.stackexchange.com/questions/94852/glm-gaussian-vs-glm-binomial-vs-log-link-glm-gaussian>). The usage of the Gaussian family - with the outcome variable as 0s and 1s as integers - has shown to make the results comparable among the different approaches used in the next sections. However, this approach would obviously not deliver Odds Ratios as no logit transform and exponentiation could be performed. Linear and logistic regression are often interchangeable (for binary outcome variables) in terms of p-value outcome, as suggested by Gomila et al, 2021, *Logistic or linear? Estimating causal effects of experimental treatments on binary outcomes using regression analysis* (https://doi.org/10.1037/xge0000920).

## We assess correlation and multicollinearity

```{r Correlation for regression analysis, fig.width=10, fig.height=10}
set.seed(1)
dend_data <- data.matrix(data_LR[c(2:66)]) #S100A8/A9 entirely skews the scale of the data.
dend_data_transp <- t(dend_data)
dend <- dend_data_transp %>% dist(method = "euclidean") %>% hclust(method='complete') %>% as.dendrogram
ggdendrogram(dend, rotate = FALSE, size = 2)

## Make QC plots to inspect data for potentially highly correlated data
## We use a simple LOESS function to observe trends in data

# SARS-CoV-2 antibodies and disease severity

pairs.panels(data_LR[c(32:39, 66)])

# PAI, anticoagulation, acute infection

pairs.panels(data_LR[c(59:65)])

# Cytokines

pairs.panels(data_LR[c(40:56)])


data_LR_Correlogr <- data_LR %>%
                dplyr::select(-PC_IgG, -PE_IgG, -PC_IgM, -Sex)

data_LR_Correlogr_matrix <- rcorr(as.matrix(data_LR_Correlogr),type="spearman")

p.mat_all <- cor.mtest(data_LR_Correlogr)

corrplot(data_LR_Correlogr_matrix$r, method="ellipse",
         col=brewer.pal(n=10, name="PuOr"), tl.col="black", tl.srt=45, tl.cex = 0.5,
         p.mat = p.mat_all, insig = "label_sig",
         sig.level = c(0.00001, 0.0001, 0.001, 0.01), pch.cex = 0.5,
         pch.col = 'red', type='lower')

```

Based on these observations

1.  Spike_IgG, RBD_IgG, NC_IgG are highly correlated with PC1_IgG;
2.  Spike_IgA, RBD_IgA, and a bit less so, NC_IgA are highly correlated with PC1_IgA;
3.  PC1_IgG and PC1_IgA are significantly correlated and probably collinear;
4.  The only feature non-significantly correlated with disease severity in the present plot may be NC_IgA;
5.  Acute infection, anticoagulation, and PAI could be used but we would restrict to anticoagulation chronic and PAI at event, dropping the event/chronic condition as they are mostly correlated and probably collinear.

We aim to challenge some of these observations using a Choleski decomposition on the correlation matrix, which includes most of these features. Choleski decomposition is a decomposition of a Hermitian positive-definite matrix into an upper (here) or lower (not used here) triangular matrix (i.e. for upper, only 0 below the diagonal) and a Hermitian transpose.

Some articles discussing aspects of Choleski decomposition:

-   <https://towardsdatascience.com/behind-the-models-cholesky-decomposition-b61ef17a65fb>
-   <https://stats.stackexchange.com/questions/52177/what-to-do-with-collinear-variables>
-   <https://stats.stackexchange.com/questions/117661/why-use-upper-triangular-cholesky>

```{r Collinearity with Choleski, fig.width=10, fig.height=10}
# We conduct a Choleski decomposition of the correlation matrix

data_LR_Choleski <- data_LR %>%
                dplyr::select(-PC_IgG, -PE_IgG, -PC_IgM, -Sex)

corelation_matrix_Choleski <- rcorr(as.matrix(data_LR_Choleski),type="spearman")
corelation_matrix_Choleski_check <- as.data.frame(corelation_matrix_Choleski$r)
Choleski <- chol(as.matrix(corelation_matrix_Choleski$r))
corrplot(Choleski, method='ellipse', tl.col='black', tl.srt=90, tl.cex=0.5, type='upper')

```

Note: We might want to combine the corrplot and the choleski decomposition plot; together, they build a whole.

Based on these observations 1. Anticoagulation chronic but especially PAI chronic have values that are closer to 0 but not extremely so; 2. Few of the aPL have values that are close to 0 but none of them extremely so; 3. The anti-SARS-CoV-2 antibodies have decreased scores and show limited collinearity; 4. PC1_IgG and PC1_IgA are clearly collinear, in case that the remaining anti-SARS-CoV-2 antibodies IgG and IgA are used; 5. Disease severity is partially collinear with other features.

<mark> There is a fair amount of correlation in the data but limited collinearity. </mark>

Overall, we shall therefore use in a dataset subset we call data_LR_collin:

-   Disease severity
-   NC_IgA, NC_IgG, Spike_IgA, Spike_IgG
-   Vaccination status
-   Acute infection (instead of chronic but the opposite would be equally plausible)
-   PAI at event
-   Anticoagulation chronic (instead of at event but the opposite would be equally plausible)
-   The cytokines do not appear as strongly collinear and do not have to be separately adjusted

## Feature selection in all data, clinical, demographic, molecular - some thoughts before we start

Before we start, one important confounder to keep in mind is the <mark> expected/hidden collinearity </mark> within the predictor variables. We have seen them earlier already in the QC plots. Some of this collinearity is just there or in itself a finding, other collinearity is desired, e.g. PC1_IgG and PC1_IgA are expected to be collinear with Spike, RBD, NC. Spike and RBD are clearly also expected to show in the same direction, including NC but only for those with infection and not those with vaccination. This means:

-   Prediction can be biased due to collinearity.
-   Some predictions may not work with a nice precision because of these confounding factors.
-   However, we are aware of it and can employ measures.

A somewhat nice overview on the problems caused by collinearity are summarised here: 

- <https://statisticsbyjim.com/regression/multicollinearity-in-regression-analysis/> 
- This is in favour of using most predictors even if they are collinear, which is essentially what we are doing here: <https://stats.stackexchange.com/questions/138168/multicollinearity-and-interaction-terms> 
- Here, the essential observation is that collinearity is something we have to live with although we can try some measures to limit its importance: <https://onlinelibrary.wiley.com/doi/full/10.1111/j.1600-0587.2012.07348.x>

*We therefore use multiple approaches for feature selection and will ultimately validate our feature choice. We will employ both frequentist-based tests suitable for testing hypotheses using GLM to perform the likelihood ratio test as well as Bayesian approaches to obtain posterior distributions by fitting a GLM using multiple priors. Additionally, we use machine learning-based random forest regression.*

Of note:

1.  We have generated a dataset where we remove some of the parameters that have shown to be highly collinear (data_LR_collin). These parameters are shown in the code.
2.  We use the molecular data (i.e. aPL, SARS-CoV-2 antibodies, or cytokines) alone in some analyses.

## Multivariate adaptive *LOGISTIC* regression spline (MARS)

We employ multivariate adaptive regression splines for feature selection as they are well suited to capture nonlinear relationships. More thoughts on the methodology can be found e.g. here: <https://uc-r.github.io/mars>.

Multivariate adaptive regression splines (MARS) provide a modular approach to capture nonlinearity by assessing knots, in a way similar to step functions but more powerfully, by avoiding higher polynomial functions. Data points for each predictor are evaluated as a knot and a linear regression model is fitted from knot to knot whereby nonlinearity can be taken care of.

- <https://cran.r-project.org/web/packages/earth/earth.pdf>
- http://www.milbo.org/doc/earth-notes.pdf

-   If the response is binary or a factor, consider using the glm argument.
    -   glm=list(family=binomial)
    -   *This is what we use*.
-   For cross validation, use the nfold argument.
-   For prediction intervals, use the varmod.method argument.

```{r MARS, message=FALSE, warning=FALSE, fig.width=10, fig.height=10}
set.seed(1)
MARS_model <- earth(Thrombosis_group ~ ., data=data_LR, 
                    nfold=10, ncross=100, varmod.method='earth', glm=list(family=binomial,
                                                                          trace=0)) # build model with 10x cross-validation (nfold)
plot(MARS_model)
print(MARS_model)
MARS_ev <- evimp(MARS_model) # estimate variable importance
print(MARS_ev)
plot(MARS_ev)

```

Observations and conclusions:

-   Disease severity is considered the top-most predictor of thromboses.
-   Antibodies against SARS-CoV-2, in particular RBD but also the compound (PCA) for IgA, are next.

## Conventional multiple GLM regression using Gaussian family with identity link

Here, we employ a conventional GLM regression approach. However, we let the stepAIC algorithm improve the model to end up with what can be considered the most meaningful combination of parameters to predict the outcome variable. Of course, we may loose potentially important but collinear features, as their 'explanatory power', by definition, is already used up by another collinear feature.

-   When this conventional model is being run as binomial(link='logit'), the problem is that much of the data does not converge (see warning message). It is pretty useless...
-   Running it under the premise of a Gaussian distribution, i.e. as a linear GLM, improves robustness (and the data actually converges nicely, without a warning). However, it comes at the cost of not being able to derive, and to interpret, the OR.
-   For this fishing approach, we convene to run this as a Gaussian GLM, i.e. linear model, and will aim to improve robustness further down using a Bayesian approach (Where we will conduct a proper multiple **logistic** regression).
- We would love to scale the data to have unit variance etc. However, we have multiple binary predictor variables. It is therefore easiest to keep the data as is. Ultimately, here, we will look at the exponentiated coefficient as a readout, for simplicity, as this is just one in many models that we employ.

```{r Conventional multiple logisitc regression, message = FALSE, fig.height = 10, fig.width = 10}
set.seed(1)

data_LR_model <- glm(Thrombosis_group~., family = gaussian(link = 'identity'), data = data_LR)
data_LR_model_collin <- glm(Thrombosis_group~., family = gaussian(link='identity'), data = data_LR_collin)
data_LR_model_aPL <- glm(Thrombosis_group~., family = gaussian(link = 'identity'), data = data_LR_aPL)
data_LR_model_CoV2 <- glm(Thrombosis_group~., family = gaussian(link = 'identity'), data = data_LR_CoV2)
data_LR_model_CK <- glm(Thrombosis_group~., family = gaussian(link = 'identity'), data = data_LR_CK)

data_LR_model_AIC <- stepAIC(data_LR_model, trace = FALSE) # We perform a variable selection with the objective to minimise the Akaike Information Criterion
data_LR_model_collin_AIC <- stepAIC(data_LR_model_collin, trace = FALSE)
data_LR_model_aPL_AIC <- stepAIC(data_LR_model_aPL, trace = FALSE)
data_LR_model_CoV2_AIC <- stepAIC(data_LR_model_CoV2, trace = FALSE)
data_LR_model_CK_AIC <- stepAIC(data_LR_model_CK, trace = FALSE)

data_LR_model$aic #What is the AIC of this model?
data_LR_model_AIC$aic #What is the AIC of this model? Is it improved?
data_LR_model_collin$aic #What is the AIC of this model?
data_LR_model_collin_AIC$aic #What is the AIC of this model? Is it improved?
data_LR_model_aPL$aic #What is the AIC of this model?
data_LR_model_aPL_AIC$aic #What is the AIC of this model? Is it improved?
data_LR_model_CoV2$aic #What is the AIC of this model?
data_LR_model_CoV2_AIC$aic #What is the AIC of this model? Is it improved?
data_LR_model_CK$aic #What is the AIC of this model?
data_LR_model_CK_AIC$aic #What is the AIC of this model? Is it improved?

data_LR_model_clean = tidy(data_LR_model, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM model") %>%
  mutate(type = 'A. All-in model')

data_LR_model_AIC_clean = tidy(data_LR_model_AIC, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM model AIC") %>%
  mutate(type = 'A. All-in model')

data_LR_model_collin_clean = tidy(data_LR_model_collin, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM model with some collinear features removed") %>%
  mutate(type = 'B. Collinearity reduced')

data_LR_model_collin_AIC_clean = tidy(data_LR_model_collin_AIC, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM model with some collinear features removed AIC") %>%
  mutate(type = 'B. Collinearity reduced')

data_LR_model_aPL_clean = tidy(data_LR_model_aPL, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM model aPL only") %>%
  mutate(type = 'C. aPL')

data_LR_model_aPL_AIC_clean = tidy(data_LR_model_aPL_AIC, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM model aPL only AIC") %>%
  mutate(type = 'C. aPL')

data_LR_model_CoV2_clean = tidy(data_LR_model_CoV2, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM model SARS-CoV-2 only") %>%
  mutate(type = 'D. SARS-CoV-2')

data_LR_model_CoV2_AIC_clean = tidy(data_LR_model_CoV2_AIC, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM SARS-CoV-2 only AIC") %>%
  mutate(type = 'D. SARS-CoV-2')

data_LR_model_CK_clean = tidy(data_LR_model_CK, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM model cytokines only") %>%
  mutate(type = 'E. Cytokines')

data_LR_model_CK_AIC_clean = tidy(data_LR_model_CK_AIC, conf.int = TRUE, exponentiate = TRUE) %>%
  mutate(Model = "Gaussian GLM cytokines only AIC") %>%
  mutate(type = 'E. Cytokines')

multiple_models = bind_rows(data_LR_model_clean, data_LR_model_AIC_clean, data_LR_model_collin_clean, data_LR_model_collin_AIC_clean, data_LR_model_aPL_clean,  data_LR_model_aPL_AIC_clean,data_LR_model_CoV2_clean, data_LR_model_CoV2_AIC_clean, data_LR_model_CK_clean, data_LR_model_CK_AIC_clean)

multiple_models = multiple_models %>%
  filter(!(term %in% c("PG_IgG","PC_IgG","PC_IgM","PC1_IgG","(Intercept)","PC1_IgA","Inflammatory_index")))

ggplot(multiple_models, aes(y = estimate, reorder(x = term, estimate), colour = Model)) +
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high),
                  size = 0.3) +
  geom_hline(yintercept = 1.0, linetype = "dotted", size = 1) +
  scale_y_log10(breaks = c(0.5, 1.0, 2.0, 5.0),
                minor_breaks = NULL) +
  labs(y = "Exponentiated coefficient (95% CI)", x = "Predictor") +
  coord_flip(ylim = c(0.25, 5)) +
  theme_bw() +
  theme(text = element_text(size = 7),element_line(linewidth =1))

multiple_models %>%
  ggplot() +
  geom_pointrange(aes(x=reorder(term, estimate),y=estimate,ymin=conf.low,ymax=conf.high,colour=Model)) +
  geom_hline(yintercept=1,linetype=2) +
  scale_colour_discrete(guide='none') +
  scale_y_log10() +
  coord_flip() +
  facet_wrap(~type,ncol=5) +
  theme(axis.text.y = element_text(size = 5)) +
  labs(y="Exponentiated coefficient (95% CI)",x="Predictors",title="Multiple Gaussian GLM regression +/- AIC improvement")

```

Observations and conclusions:

-   PAI at event is scoring as the most positively associated feature, however, it has a large uncertainty. Its importance wanes immediately as we use the collinearity-reduced dataset; PAI chronic was responsible for the effect seen.
-   stepAIC simplified and thereby improved the model.
-   Severity, NC_IgG, NC_IgA, Spike_IgA, perhaps Spike_IgG are positively associated.
-   None of the aPL has an effect.
-   There is no indication for cytokines to modulate the thrombotic risk.

*Note that we lost PG_IgG, PC_IgG, PC_IgM, PC1_IgG, PC1_IgA, and Inflammatory_index on the way.*

## Multiple logistic regression in Bayesian framework

As we have done in our original manuscript published in iScience (https://doi.org/10.1016/j.isci.2023.105928), we look at the data from a Bayesian viewpoint, using an interface to run a multiple logistic regression in STAN. As we have done before, we employ three different priors, a mostly uninformative prior (Normal(0,10)), a LASSO prior and a regularised horseshoe. We can thereby deal with results in a comparative manner. Using LASSO and regularised horseshoe shrinkage priors, we expect the regression to be more stable than the conventional multiple regression analysis performed above or the one where an uninformative prior is employed. The increased robustness allows us to employ the proper model for the data, i.e. to run a proper logistic regression with binomial family and logit link function. The choice of priors is nicely explained here:

-   <https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations>
-   <https://projecteuclid.org/journals/bayesian-analysis/volume-12/issue-1/Hierarchical-Shrinkage-Priors-for-Regression-Models/10.1214/15-BA990.full>
-   <https://cran.r-project.org/web/packages/rstanarm/vignettes/binomial.html>

<mark> The code was originally designed by Julien Riou, who is a coauthor in the study published here (https://doi.org/10.1016/j.isci.2023.105928). The code is available on Zenodo and will have to be referenced as well (<https://doi.org/10.5281/zenodo.7454292>). </mark>

See also here (<https://avehtari.github.io/modelselection/regularizedhorseshoe_slides.pdf>) for further inspiration and insights into the method.

For the Bayesian analysis, the data requires a bit of preprocessing as constant variables are not accepted in the analysis. We have to, therefore, exclude:

-   PC_IgG
-   PC_IgM

```{r Bayesian regression preprocessing, message = FALSE, fig.height = 10, fig.width = 10}

data_LR_Bayes <- data_LR %>% 
  dplyr::select(-PC_IgG, -PC_IgM
                )
```

### Normal(0,10) uninformative prior

```{r Bayesian regression uninformative, message = FALSE, warning = FALSE, fig.height = 10, fig.width = 10}
m1_lin = stan_glm(Thrombosis_group~.,
                  family=binomial(link = "logit"),
                  prior=normal(0,10),
                  prior_intercept = normal(0,10),
                  data=data_LR_Bayes)
summary(m1_lin)
s1_lin = summary(m1_lin,probs = c(0.025,.5,0.975)) %>%
  as.data.frame() %>%
  rownames_to_column() %>% 
  as_tibble() %>%
  filter(!(rowname %in% c("log-posterior","mean_PPD","(Intercept)","sigma"))) %>%
  mutate(rowname=gsub("TRUE","",rowname),
         OR=exp(`50%`), #the backticks, or grave accents, are used for non-syntactic names/combinations
         OR_low=exp(`2.5%`),
         OR_high=exp(`97.5%`),
         type="Uninformative prior") %>%
  arrange(-abs(`50%`))
```

### LASSO

```{r Bayesian regression LASSO, message = FALSE, warning = FALSE, fig.height = 10, fig.width = 10}
m1_lasso = stan_glm(Thrombosis_group~.,
                    family=binomial(link = "logit"),
                    prior=lasso(df=1),
                    data=data_LR_Bayes)
summary(m1_lasso)
s1_lasso = summary(m1_lasso,probs = c(0.025,.5,0.975)) %>%
  as.data.frame() %>%
  rownames_to_column() %>% 
  as_tibble() %>%
  filter(!(rowname %in% c("log-posterior","mean_PPD","(Intercept)","sigma"))) %>%
  mutate(rowname=gsub("TRUE","",rowname),
         OR=exp(`50%`),
         OR_low=exp(`2.5%`),
         OR_high=exp(`97.5%`),
         type="LASSO") %>%
  arrange(-abs(`50%`))
```

### Regularised horseshoe (Piironen and Vehtari (2017), <https://doi.org/10.1214/17-EJS1337SI>)

The regulairsed horseshoe prior is a generalisation of the horseshoe prior that allows us to specify a minimum level of regularization to the largest values (Piironen and Vehtari (2017), <https://doi.org/10.1214/17-EJS1337SI>)

Here, they recommend to set the globalscale argument equal to the ratio of the expected number of non-zero coefficients to the expected number of zero coefficients, divided by the square root of the number of observations.

-   Example for small dataset (18/110)/sqrt(128)
-   Example for large dataset (35/1500)/sqrt(1535)
-   What we have used for SARS-CoV-2 (<https://doi.org/10.1101/2020.05.31.20118554>, <https://doi.org/10.5281/zenodo.7454292>), (19/570)/sqrt(589)
-   globalscale = p0 / (D - p0) * 1 / sqrt(N) with
      - p0 = prior guess for the number of relevant (i.e., non-zero) regression coefficients/'variables',
      - N = Number of observations,
      - D = Number of regression coefficients or Number of 'variables',

The utilisation of this shrinkage prior shrinks the beta coefficients towards zero while the local parameters allow some of the beta coefficient, i.e. features, to escape the shrinkage (<https://avehtari.github.io/modelselection/regularizedhorseshoe_slides.pdf>). This is why this is a valid approach to identify relevant parameters.

```{r Bayesian regression regularised horseshoe, message = FALSE, warning = FALSE, fig.height = 10, fig.width = 10}
globalscale = (18/110)/sqrt(128)
                                
m1_hs = stan_glm(Thrombosis_group~.,
                 family=binomial(link = "logit"),
                 prior=hs(global_scale=globalscale),
                 data=data_LR_Bayes)
summary(m1_hs)
s1_hs = summary(m1_hs,probs = c(0.025,.5,0.975)) %>%
  as.data.frame() %>%
  rownames_to_column() %>% 
  as_tibble() %>%
  filter(!(rowname %in% c("log-posterior","mean_PPD","(Intercept)","sigma"))) %>%
  mutate(rowname=gsub("TRUE","",rowname),
         OR=exp(`50%`),
         OR_low=exp(`2.5%`),
         OR_high=exp(`97.5%`),
         type="Regularized horseshoe") %>%
  arrange(-abs(`50%`))
```

### Bring them together

```{r Bayesian regression - bring them together, message = FALSE, fig.height = 10, fig.width = 10}

post_icd10 = bind_rows(s1_lasso,s1_hs,s1_lin) %>%
  mutate(rowname=factor(rowname,levels=s1_hs$rowname[order(s1_hs$`50%`)]),
         type=factor(type,levels=c("Uninformative prior","LASSO","Regularized horseshoe")))
saveRDS(post_icd10,file="post_icd10.rds")

ranks = filter(post_icd10,type=="Regularized horseshoe") %>%
  arrange(-`50%`) %>%
  mutate(rank=row_number()) %>%
  mutate(ICD10=rowname) %>%
  dplyr::select(ICD10,rank)

tibble_post_icd10 <- post_icd10 %>%
  mutate(OR=paste0(sprintf("%.2f",OR)," (",sprintf("%.2f",OR_low),"-",sprintf("%.2f",OR_high),")")) %>%
  dplyr::select(ICD10=rowname,OR,type) %>%
  pivot_wider(names_from=type,values_from=OR) %>%
  left_join(ranks) %>%
  arrange(rank) %>% 
  filter(rank %in% c(1:10,(max(rank)-9):max(rank))) %>%
  dplyr::select(rank,ICD10,`Uninformative prior`,LASSO,`Regularized horseshoe`)
write.csv(tibble_post_icd10,"tibble_post_icd10_ranktable.csv")
print(tibble_post_icd10)

post_icd10 %>%
  mutate(type=factor(type,labels=c("Unregularized","LASSO","Regularized Horseshoe"))) %>%
  ggplot() +
  geom_pointrange(aes(x=rowname,y=OR,ymin=OR_low,ymax=OR_high,colour=type)) +
  geom_hline(yintercept=1,linetype=2) +
  scale_colour_discrete(guide='none') +
  scale_y_log10() +
  coord_flip() +
  facet_wrap(~type,ncol=3, scales = "free_x") +
  theme(axis.text.y = element_text(size = 5)) +
  labs(y="Odds ratio (95% credible interval)",x="Predictors",title="Multiple logistic regression in Bayesian framework")

write.csv(post_icd10,"post_icd10_ranktable.csv")
```

Observations and conclusions:

-   In this Bayesian multiple logistic regression, the usage of the uninformative prior has mounded in the expected statistical fluctuation with large credible intervals.
-   We note that the approach was generally more robust than the conventional GLM; the outcome of the uninformative prior resembles what we had observed with the conventional gaussian GLM.
-   LASSO and regularised horseshoe prior distributions properly deal with this fluctuation.
    -   Disease severity stands out as the only positive association, markedly with regularised horseshoe.
    -   No noteworthy negative association.

## Boruta

Essentially, we aim to run a random forest regression and to select only those parameters whose importance is above a certain threshold.

1.  Rather than relying on or competing with other features, Boruta creates shadows of every single feature by randomly shuffling them; the shadow features (step 1).
2.  Following the generation of the shadow features, which is essentially a duplication of the dataset by shuffling all values in each column, a random forest is fitted on the them using the outcome variable (step 2).
3.  At each iteration, the algorithm assesses whether the original feature has a higher importance than the highest of its shadow features. As a measure of importance, the Mean Decrease Accuracy is used, with higher scores being more important. The z-score represents the number of standard deviations from the mean data point. Unimportant features are dismissed.
4.  This is done iteratively, i.e. the whole process is being repeated multiple times (in our case: 1000 times) so that a distribution of importance is attributed to each feature.
5.  The algorithm stops either at a predefined maximum iteration or when all features are confirmed or rejected.
6.  Subsequently, the importance of each of the original features is visualised. If the original feature importance is higher than the threshold, the feature is 'confirmed important'. If there is insecurity, it may be 'tentative'. Else, it is 'confirmed unimportant'.

More details can be found here:

-   <https://towardsdatascience.com/boruta-explained-the-way-i-wish-someone-explained-it-to-me-4489d70e154a>
-   <https://www.andreaperlato.com/mlpost/feature-selection-using-boruta-algorithm/>
-   <https://cran.r-project.org/web/packages/Boruta/Boruta.pdf>
-   <https://www.datacamp.com/tutorial/feature-selection-R-boruta>
-   <https://www.analyticsvidhya.com/blog/2016/03/select-important-variables-boruta-package/>

We expect Boruta not to be confounded by interdependencies of variables. However, once we build our final model in a later step, we may have to account for collinear features again.

```{r Boruta, message = FALSE, fig.height = 10, fig.width = 10}
set.seed(1)
boruta_output <- Boruta(Thrombosis_group ~ ., data=na.omit(data_LR), doTrace=2, maxRuns=1000)  # perform Boruta search
boruta_signif <- names(boruta_output$finalDecision[boruta_output$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
print(boruta_signif)  # significant variables
getNonRejectedFormula(boruta_output)
plotImpHistory(boruta_output)
plot(boruta_output, cex.axis=.4, las=2, xlab="", main="Variable Importance")  # plot variable importance

```

Observations and conclusions:

-   Boruta confirms many of the results we have observed before.
    -   Severity is the most important predictor.
    -   NC_IgA and Spike_IgA in general seem important.
    -   The anti-SARS-CoV-2 IgGs are important, too.
-   There is no competition among features here as collinearity is not an issue.
-   The model suggests that B2GPI_IgM is an important feature.
-   The model suggests that acute infection with SARS-CoV-2 is an important feature.

## Use the most important features to build model

### Conclusions from the approaches above and model creation

Let us list some of the consensus information here:

1. Severity is the most important predictor.
2. All anti-SARS-CoV-2 measurements, including their linear combinations, contain important information. It is unclear which of them is more essential than another one as they are largely, but not entirely, overlapping, i.e. collinear, except for NC IgA. All of them shall be tried.
3. B2GPI IgM may be somehow associated and it can be tested in a model.
4. Among the cytokines, GCSF, Inflammatory index, IFN alpha, IL4, IL6, IL8, IL10, SDF1 alpha have found to carry some importance.

A good way to go about this is to:

1.  Test and include those parameters that have shown most promising in above models.
2.  Account for collinearity. What cannot be accounted for during preprocessing will be looked into during model development, following a step-wise approach.
    + We go from simple to more complex.
    + When adding a parameter, we check whether this improves the model's AIC. If not, we drop the parameter and add another one.
    + We also consider the residual deviance.
    + We aim to end up with the simplest model possible, i.e. we avoid redundant parameters.
3.  We employ a generalised linear model (GLM). If needed, we might use a generalised linear mixed model, e.g. LME4 <https://www.rdocumentation.org/packages/lme4/versions/1.1-31>), as appropriate. For some insights into mixed-effects models and their application, see <https://stats.stackexchange.com/questions/275450/when-to-use-mixed-effect-model>.

```{r Create using best model, fig.height = 10, fig.width = 10}
set.seed(1)

model1 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 109.1, residual deviance 105.1, df=111

model2 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgG, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 111.1, residual deviance 98.89, df=111

model3 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 106.1, residual deviance 100.1, df=111

model4 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 104.2, residual deviance 96.24, df=111

model5 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + PC1_IgA, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 105.9, residual deviance 95.91, df=111

model6 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgG, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 106.1, residual deviance 96.09, df=111

model7 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 104.6, residual deviance 94.08, df=111

model8 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 101.6, residual deviance 89.62, df=111

model9 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 97.12, residual deviance 83.12, df=111

model10 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 97.38, residual deviance 81.38, df=111

model11 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM + GCSF, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 91.41, residual deviance 73.41, df=111

model12 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM + GCSF + Inflammatory_index, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 90.29, residual deviance 70.29, df=111

model13 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM + GCSF + Inflammatory_index + IFNalpha, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 91.58, residual deviance 69.58, df=111

model14 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM + GCSF + Inflammatory_index + IL4, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 89.91, residual deviance 67.91, df=111

model15 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM + GCSF + Inflammatory_index + IL4 + IL6, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 87.93, residual deviance 63.93, df=111

model16 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM + GCSF + Inflammatory_index + IL4 + IL6 + IL8, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 89.88, residual deviance 63.88, df=111

model17 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM + GCSF + Inflammatory_index + IL4 + IL6 + IL10, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 89.92, residual deviance 63.92, df=111

model18 <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM + GCSF + Inflammatory_index + IL4 + IL6 + SDF1alpha, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
# AIC: 89.55, residual deviance 63.55, df=111

```

### We make predictions using the best model

```{r Make predicitions using best model, fig.height = 10, fig.width = 10}

best_model <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA + PC1_IgG + Spike_IgA + RBD_IgG + RBD_IgA +
               ß2GPI_IgM + GCSF + Inflammatory_index + IL4 + IL6 + SDF1alpha, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
summary(best_model)


best_model_AIC <- stepAIC(best_model) #We want to have a model that is as simple as possible.
summary(best_model_AIC)

minimum_model <- glm(Thrombosis_group ~ SeverityCoV2_or_Flu_int + NC_IgA, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
summary(minimum_model)

additional_model <- glm(Thrombosis_group ~ ß2GPI_IgM + GCSF + Inflammatory_index + IL4 + IL6 + SDF1alpha, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
summary(additional_model)

cyto_model <- glm(Thrombosis_group ~ GCSF + Inflammatory_index + IL4 + IL6 + SDF1alpha, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
summary(cyto_model)

aPL_model <- glm(Thrombosis_group ~ ß2GPI_IgM, 
                  data = data_LR, 
                  family = binomial(link = 'logit'))
summary(aPL_model)

probabilities <- best_model %>% predict(data_LR, type = "response")
summary(probabilities)

probabilities_AIC <- best_model_AIC %>% predict(data_LR, type = "response")
summary(probabilities_AIC)

probabilities_minimum <- minimum_model %>% predict(data_LR, type = "response")
summary(probabilities_minimum)

probabilities_additional <- additional_model %>% predict(data_LR, type = "response")
summary(probabilities_additional)

probabilities_cyto <- cyto_model %>% predict(data_LR, type = "response")
summary(probabilities_cyto)

probabilities_aPL <- aPL_model %>% predict(data_LR, type = "response")
summary(probabilities_aPL)

contrasts(as.factor(data_LR$Thrombosis_group))

predicted.classes <- ifelse(probabilities > 0.5, "1", "0")
print(predicted.classes)

predicted.classes_AIC <- ifelse(probabilities_AIC > 0.5, "1", "0")
print(predicted.classes_AIC)

predicted.classes_minimum <- ifelse(probabilities_minimum > 0.5, "1", "0")
print(predicted.classes_minimum)

predicted.classes_additional <- ifelse(probabilities_additional > 0.5, "1", "0")
print(predicted.classes_additional)

predicted.classes_cyto <- ifelse(probabilities_cyto > 0.5, "1", "0")
print(predicted.classes_cyto)

predicted.classes_aPL <- ifelse(probabilities_aPL > 0.5, "1", "0")
print(predicted.classes_aPL)

mean(predicted.classes == data_LR$Thrombosis_group)

mean(predicted.classes_AIC == data_LR$Thrombosis_group)

mean(predicted.classes_minimum == data_LR$Thrombosis_group)

mean(predicted.classes_additional == data_LR$Thrombosis_group)

mean(predicted.classes_cyto == data_LR$Thrombosis_group)

mean(predicted.classes_aPL == data_LR$Thrombosis_group)

# We can visualise these models in six independent plots

data_LR$Thrombosis_group_predicted <- as.numeric(predicted.classes)
data_LR$Thrombosis_group_predicted_prob <- as.numeric(probabilities)

data_LR$Thrombosis_group_predicted_AIC <- as.numeric(predicted.classes_AIC)
data_LR$Thrombosis_group_predicted_prob_AIC <- as.numeric(probabilities_AIC)

data_LR$Thrombosis_group_predicted_minimum <- as.numeric(predicted.classes_minimum)
data_LR$Thrombosis_group_predicted_prob_minimum <- as.numeric(probabilities_minimum)

data_LR$Thrombosis_group_predicted_additional <- as.numeric(predicted.classes_additional)
data_LR$Thrombosis_group_predicted_prob_additional <- as.numeric(probabilities_additional)

data_LR$Thrombosis_group_predicted_cyto <- as.numeric(predicted.classes_cyto)
data_LR$Thrombosis_group_predicted_prob_cyto <- as.numeric(probabilities_cyto)

data_LR$Thrombosis_group_predicted_aPL <- as.numeric(predicted.classes_aPL)
data_LR$Thrombosis_group_predicted_prob_aPL <- as.numeric(probabilities_aPL)

ggplot(data = data_LR, aes(x = Thrombosis_group_predicted_prob, y = Thrombosis_group)) +
  geom_pointrange(aes(ymin = Thrombosis_group, ymax = Thrombosis_group)) +
  geom_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='blue') +
  stat_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='blue', lty='dotted', geom='ribbon', fill=NA) +
  labs(y="Observed values",x="Predicted values (best model)",title="")

ggplot(data = data_LR, aes(x = Thrombosis_group_predicted_prob_AIC, y = Thrombosis_group)) +
  geom_pointrange(aes(ymin = Thrombosis_group, ymax = Thrombosis_group)) +
  geom_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='green') +
  stat_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='green', lty='dotted', geom='ribbon', fill=NA) +
  labs(y="Observed values",x="Predicted values (AIC-improved model)",title="")

ggplot(data = data_LR, aes(x = Thrombosis_group_predicted_prob_minimum, y = Thrombosis_group)) +
  geom_pointrange(aes(ymin = Thrombosis_group, ymax = Thrombosis_group)) +
  geom_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='brown') +
  stat_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='brown', lty='dotted', geom='ribbon', fill=NA) +
  labs(y="Observed values",x="Predicted values (minimal model)",title="")

ggplot(data = data_LR, aes(x = Thrombosis_group_predicted_prob_additional, y = Thrombosis_group)) +
  geom_pointrange(aes(ymin = Thrombosis_group, ymax = Thrombosis_group)) +
  geom_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='violet') +
  stat_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='violet', lty='dotted', geom='ribbon', fill=NA) +
  labs(y="Observed values",x="Predicted values (additional model)",title="")

ggplot(data = data_LR, aes(x = Thrombosis_group_predicted_prob_cyto, y = Thrombosis_group)) +
  geom_pointrange(aes(ymin = Thrombosis_group, ymax = Thrombosis_group)) +
  geom_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='grey') +
  stat_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='grey', lty='dotted', geom='ribbon', fill=NA) +
  labs(y="Observed values",x="Predicted values (additional model)",title="")

ggplot(data = data_LR, aes(x = Thrombosis_group_predicted_prob_aPL, y = Thrombosis_group)) +
  geom_pointrange(aes(ymin = Thrombosis_group, ymax = Thrombosis_group)) +
  geom_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='black') +
  stat_smooth(method = "glm", 
              method.args = list(family = binomial()), colour='black', lty='dotted', geom='ribbon', fill=NA) +
  labs(y="Observed values",x="Predicted values (additional model)",title="")

# We use an alternative visualisation, more condensed
Thrombosis_group_predicted_prob <- data.frame(prob=as.numeric(probabilities)) %>%
  dplyr::mutate(Model='A. best model') %>%
  data.frame(observed=data_LR$Thrombosis_group)

Thrombosis_group_predicted_prob_AIC <- data.frame(prob=as.numeric(probabilities_AIC)) %>%
  dplyr::mutate(Model='B. AIC improved model') %>%
  data.frame(observed=data_LR$Thrombosis_group)

Thrombosis_group_predicted_prob_minimum <- data.frame(prob=as.numeric(probabilities_minimum)) %>%
  dplyr::mutate(Model='C. minimal model') %>%
  data.frame(observed=data_LR$Thrombosis_group)

Thrombosis_group_predicted_prob_additional <- data.frame(prob=as.numeric(probabilities_additional)) %>%
  dplyr::mutate(Model='D. additional model') %>%
  data.frame(observed=data_LR$Thrombosis_group)

Thrombosis_group_predicted_prob_cyto <- data.frame(prob=as.numeric(probabilities_cyto)) %>%
  dplyr::mutate(Model='E. cyto model') %>%
  data.frame(observed=data_LR$Thrombosis_group)

Thrombosis_group_predicted_prob_aPL <- data.frame(prob=as.numeric(probabilities_aPL)) %>%
  dplyr::mutate(Model='F. aPL model') %>%
  data.frame(observed=data_LR$Thrombosis_group)

Regmodel_bind = bind_rows(Thrombosis_group_predicted_prob, Thrombosis_group_predicted_prob_AIC, Thrombosis_group_predicted_prob_minimum, Thrombosis_group_predicted_prob_additional,Thrombosis_group_predicted_prob_cyto,Thrombosis_group_predicted_prob_aPL)

logregplot <-
ggplot(data = Regmodel_bind, aes(x = prob, y = observed, color=Model)) +
  geom_pointrange(aes(ymin = observed, ymax = observed)) +
  geom_smooth(method = "glm", 
              method.args = list(family = binomial())) +
  stat_smooth(method = "glm", 
              method.args = list(family = binomial()), lty='dotted', geom='ribbon', fill=NA) +
  scale_color_manual(values=c('blue','green','brown','violet','grey','black')) +
  labs(y="Observed values",x="Predicted values",title="") +
  facet_wrap(~Model,ncol=6)

```

### Visualise best model in a ROC curve

```{r ROC curve of models, fig.height = 10, fig.width = 10}
# We build a ROC curve for the actual probabilities (non-binarised)
pred_object_prob <-prediction(data_LR$Thrombosis_group_predicted_prob,data_LR$Thrombosis_group)
ROC_curve_prob <-performance(pred_object_prob,"tpr","fpr")
ROC_curve_prob_GG <- data.frame(FPR=ROC_curve_prob@x.values[[1]],TPR=ROC_curve_prob@y.values[[1]]) %>%
  dplyr::mutate(Model='A. best model')
auc_best_model <- performance(pred_object_prob, measure = "auc")
auc_best_model_value <- round(auc_best_model@y.values[[1]],4)

pred_object_prob_AIC <-prediction(data_LR$Thrombosis_group_predicted_prob_AIC,data_LR$Thrombosis_group)
ROC_curve_prob_AIC <-performance(pred_object_prob_AIC,"tpr","fpr")
ROC_curve_prob_AIC_GG <- data.frame(FPR=ROC_curve_prob_AIC@x.values[[1]],TPR=ROC_curve_prob_AIC@y.values[[1]]) %>%
  dplyr::mutate(Model='B. AIC improved model')
auc_best_model_AIC <- performance(pred_object_prob_AIC, measure = "auc")
auc_best_model_AIC_value <- round(auc_best_model_AIC@y.values[[1]],4)

pred_object_prob_minimal <-prediction(data_LR$Thrombosis_group_predicted_prob_minimum,data_LR$Thrombosis_group)
ROC_curve_prob_minimal <-performance(pred_object_prob_minimal,"tpr","fpr")
ROC_curve_prob_minimal_GG <- data.frame(FPR=ROC_curve_prob_minimal@x.values[[1]],TPR=ROC_curve_prob_minimal@y.values[[1]])%>%
  dplyr::mutate(Model='C. minimal model')
auc_minimal <- performance(pred_object_prob_minimal, measure = "auc")
auc_minimal_value <- round(auc_minimal@y.values[[1]],4)

pred_object_prob_additional <-prediction(data_LR$Thrombosis_group_predicted_prob_additional,data_LR$Thrombosis_group)
ROC_curve_prob_additional <-performance(pred_object_prob_additional,"tpr","fpr")
ROC_curve_prob_additional_GG <- data.frame(FPR=ROC_curve_prob_additional@x.values[[1]],TPR=ROC_curve_prob_additional@y.values[[1]])%>%
  dplyr::mutate(Model='D. additional model')
auc_additional <- performance(pred_object_prob_additional, measure = "auc")
auc_additional_value <- round(auc_additional@y.values[[1]],4)

pred_object_prob_cyto <-prediction(data_LR$Thrombosis_group_predicted_prob_cyto,data_LR$Thrombosis_group)
ROC_curve_prob_cyto <-performance(pred_object_prob_cyto,"tpr","fpr")
ROC_curve_prob_cyto_GG <- data.frame(FPR=ROC_curve_prob_cyto@x.values[[1]],TPR=ROC_curve_prob_cyto@y.values[[1]])%>%
  dplyr::mutate(Model='E. cyto model')
auc_cyto <- performance(pred_object_prob_cyto, measure = "auc")
auc_cyto_value <- round(auc_cyto@y.values[[1]],4)

pred_object_prob_aPL <-prediction(data_LR$Thrombosis_group_predicted_prob_aPL,data_LR$Thrombosis_group)
ROC_curve_prob_aPL <-performance(pred_object_prob_aPL,"tpr","fpr")
ROC_curve_prob_aPL_GG <- data.frame(FPR=ROC_curve_prob_aPL@x.values[[1]],TPR=ROC_curve_prob_aPL@y.values[[1]])%>%
  dplyr::mutate(Model='F. aPL model')
auc_aPL <- performance(pred_object_prob_aPL, measure = "auc")
auc_aPL_value <- round(auc_aPL@y.values[[1]],4)

ROCplot = bind_rows(ROC_curve_prob_GG, ROC_curve_prob_AIC_GG, ROC_curve_prob_minimal_GG, ROC_curve_prob_additional_GG,ROC_curve_prob_cyto_GG,ROC_curve_prob_aPL_GG)

ROCplot_graph <-
ggplot() +
    geom_line(data=ROCplot,aes(x=FPR,y=TPR, color=Model), size = 0.8) +
    geom_line(aes(x=c(0,1),y=c(0,1)), color="red") +
    geom_vline(xintercept = 1) +
    geom_hline(yintercept = 0) +
    scale_color_manual(values=c('blue','green','brown','violet','grey','black')) +
    xlab("False Positive Rate (1-Specificity)") +
    ylab("True Positive Rate (Sensitivity)") +
    annotate("text", x = .75, y = .30, label = paste("AUC =", auc_best_model_value), color='blue') +
    annotate("text", x = .75, y = .25, label = paste("AUC =", auc_best_model_AIC_value), color='green') +
    annotate("text", x = .75, y = .20, label = paste("AUC =", auc_minimal_value), color='brown') +
    annotate("text", x = .75, y = .15, label = paste("AUC =", auc_additional_value), color='violet') +
    annotate("text", x = .75, y = .10, label = paste("AUC =", auc_cyto_value), color='grey') +
    annotate("text", x = .75, y = .05, label = paste("AUC =", auc_aPL_value), color='black')

ggarrange(logregplot, ROCplot_graph,
          labels = c("A", "B"),
          ncol = 1, nrow = 2)

```

What are the conclusions we can derive from all this?

1.  Under the given premises, we have not been able to establish a strong connection between the occurrence of aPL and thrombotic events:
    -   aPL have not popped up in any analysis, except for B2GPI_IgM in Boruta.
    -   We claim that for a hypothesis to be accepted, there needs to be solid evidence. In this case, the evidence is weak and potentially nonexistent. This means that the hypothesis that the increased aPL levels observed in individuals with concurrent or subsequent to infection with SARS-CoV-2 may be causally related to a higher incidence of thrombotic events is refuted.
    -   However, the model suggests that B2GPI_IgM levels are weakly modulating the risk for thrombotic events as a part of the model of choice.
2.  We have then looked more broadly to identify potential associations with other molecular and/or clinical/demographic data:
    -   Unsurprisingly, we find associations with SARS-CoV-2.
    -   We find the strongest association with disease severity, i.e. patients with increased acute disease burden are more likely to develop thrombotic events concomitantly or later on.
    -   SARS-CoV-2 disease severity is, in part, correlated with the strength of the antibody response against SARS-CoV-2.
    -   Nevertheless, some effects were exerted by the presence of anti-SARS-CoV-2 antibodies in addition to disease severity.
    -   Thus, antiviral immune reaction seems to be associated.
    -   Demographic data (age/sex) had no effective predictive value.
    -   Some cytokine levels were found to be additional modulators of risk of thromboses, particularly G-CSF, which is known to induce thrombocytopenia. IL-6 is a documented risk factor for coagulopathies shown here (https://www.nature.com/articles/s41569-021-00665-7) and elsewhere.

*The occurrence of aPL antibodies after infection with SARS-CoV-2, which is a well-described phenomenon and has shown to be partially modulated by the strength of the anti-viral immune response, and the occurrence of thrombotic events concomitant to or subsequent to infection with SARS-CoV-2, are therefore two independent events, both of which have a common cause: infection with SARS-CoV-2.*

The most exciting follow-up would be to employ this model in a further cohort to validate the predictors.

# ORIGINAL COMPUTING ENVIRONMENT {.tabset .tabset-fade .tabset-pills}

```{r SESSION INFO, fig.height = 10, fig.width = 10}

sessionInfo()

```

